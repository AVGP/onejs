// Copyright (C) 2014 OneJS
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

import math
import text

// text with extra tag struct
class TaggedTextImpl extends TextImpl{
	
	dontProxy('tag_x','tag_y','alloc_tags')

	tag_x = 0
	tag_y = 0

	charTag(off){
		return vec4[] alloc_tags[off * 6]
	}
	
	charTag_z(off){
		return vec4[] alloc_tags[off * 6].z
	}

	reserialize(){
		var s = ''
		vec4[] buf = alloc_tags
		for(var i = 0;i<char_off;i++){
			s += String.fromCharCode(buf[i*6].z)
		}
		return s
	}
	
	// turn a baseline into a an approximate top
	baseToTop(y){
		return y + font_size * cursor_sink - line_height 
	}

	// fetch the baseline of a character by offset
	charBaseline(off){
		// scan backwards to newline and add a line.
		// if 0 return 0
		var o = off * 6
		vec4[] tags = alloc_tags
		vec4[] mesh = alloc_mesh
		while(o >= 0){
			if(tags[o].z == 10){
				var base = mesh[o].y
				if(off*6 != o) base += line_height
				return base
			} // newline
			o--
		}
		return 0
	}

	// return the cursor rectangle based on an offset
	cursorRect(off){
		var bounds = charBounds(off)
		var base = charBaseline(off)
		var height = line_height//font_size * cursor_spacing
		base += font_size * cursor_sink
		return {
			x:bounds.x
			y:base - height
			w:bounds.w
			h:height
		}
	}

	// calculate the cursor offset from mouse position
	offsetFromPos(x, y){
		vec4[] tags = alloc_tags
		vec4[] mesh = alloc_mesh
		var height = line_height
		for(var o = alloc_off - 6; o >= 0; o -= 6){
			if(o == 0 || tags[o].z == 10){
				// the baseline
				var base = o==0 ? 0: mesh[o].y
				base += font_size * cursor_sink
				//console.log(base-height, y, base)
				if(y < base && y >= base - height){
					while(o >= 0){
						var hx = (mesh[o].x + mesh[o+1].x)/2
						if(x >= mesh[o].x && x < hx){
							return o/6
						}
						if(x > hx){
							if(tags[o].z == 10) return o / 6
							return o / 6 + 1
						}
						o -=6
					}
					return -1
				}
			}
		}
		return -1
	}
	tags = vec4[]()
	tag_pos: vec2(floor(mod(abs(tags[].w),256.)), floor(abs(tags[].w)/256.))
	
	tagChar(off, length, x, y, z){
		var o = off
		vec4[] buf = alloc_tags
		for(var i = 0; i < length; i++){
			buf[o].x = x
			buf[o].y = y
			buf[o].z = z
			buf[o].w = 0.1
			o++
			buf[o].x = x
			buf[o].y = y
			buf[o].z = z
			buf[o].w = 1
			o++
			buf[o].x = x
			buf[o].y = y
			buf[o].z = z
			buf[o].w = 256
			o++
			buf[o].x = x
			buf[o].y = y
			buf[o].z = z
			buf[o].w = 256
			o++
			buf[o].x = x
			buf[o].y = y
			buf[o].z = z
			buf[o].w = 1
			o++
			buf[o].x = x
			buf[o].y = y
			buf[o].z = z
			buf[o].w = 257
			o++
		}
	}

	reallocText(extra){

		vec4[] old_tags = alloc_tags
		var old_length = alloc_length

		TextImpl::reallocText(extra)

		alloc_tags = vec4[alloc_length]()
		vec4[] ntags = alloc_tags
		for(var i = 0;i<old_length;i++){
			ntags[i].x = old_tags[i].x
			ntags[i].y = old_tags[i].y
			ntags[i].z = old_tags[i].z
			ntags[i].w = old_tags[i].w
		}
	}

	allocText(length){
		TextImpl::allocText(length)
		alloc_tags = vec4[alloc_length]()
	}

	updateText(){
		TextImpl::updateText()
		tags = alloc_tags
	}
	/*
	insertText(offset, length){
		var from = alloc_off
		var to = alloc_off + length * 6
		for(var i = start64;i>=offset;i-=6){
			var i1 = i+length
			mesh[i1].x = mesh[i].x
			mesh[i1].y = mesh[i].y
			mesh[i1].z = mesh[i].z
			mesh[i1].w = mesh[i].w
		}
	}*/

	newline(t = 1){
		var off = alloc_off
		if(alloc_off + t * 6 > alloc_length) reallocText(alloc_off / 6 + t)
		var i = TextImpl::newline(t)
		tagChar(off, i, tag_x, tag_y, 10)
		return i
	}

	tab(t = 1){
		var off = alloc_off
		if(alloc_off + t * 6 > alloc_length) reallocText(alloc_off / 6 + t)
		var i = TextImpl::tab(t)
		tagChar(off, i, tag_x, tag_y, 9)
		return i
	}

	space(t = 1){
		var off = alloc_off
		if(alloc_off + t * 6 > alloc_length) reallocText(alloc_off / 6 + t)
		var i = TextImpl::space(t)
		tagChar(off, i, tag_x, tag_y, 32)
		return i
	}

	string(text, x, y){
		if(x !== undefined) add_x = x 
		if(y !== undefined) add_y = y 
		var length = text.length
		var chars = 0
		if(alloc_off + length * 6 > alloc_length) reallocText(alloc_off / 6 + length)

		// alright lets convert some text babeh!
		for(var i = 0; i < length; i++){
			var unicode = text.charCodeAt(i)

			// parse inline tags
			if(inline_tags && (unicode == 36||unicode==37)){
				var t = i
				var next
				while((next = text.charCodeAt(t+1)) >= 48 && next <=57){
					t++
				}
				if(i != t){
					var out = parseInt(text.slice(i+1, i-t))
					if(unicode == 36) tag_x = out
					else tag_y = out
					i = t
					continue
				}
			}
			if(unicode == 32){
				chars += space()
				continue
			}
			if(unicode == 10){ // newline
				chars += newline()
				continue
			}
			if(unicode == 9){ // tab
				chars += tab()
			}
			var glyph = glyphy_info.glyphs[unicode]
			if(!glyph){
				chars += space()
				continue
			}
			// lets add some vertices
			var off = alloc_off
			addChar(glyph)
			chars++
			tagChar(off, 1, tag_x, tag_y, unicode)
		}
		if(add_y > _text_h) _text_h = add_y	
		return chars
	}
}
