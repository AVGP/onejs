var assert = load('assert')

var {Root, Rect} = load('dom')

Dom1(){
	Root{
		init(document.body)
		class MyDiv extends Rect{
			w = 10
			h = 10
		}
		profile(3000) do(){
			MyDiv{
				fill = [random(),random(),random()]
				x = random() * 300
				y = random() * 300
			}
		}
	}
}

Signals(){
	var t = Base{
		x: 10,
		y: x + 10
		assert( y == 20 )
		x:20
		assert( y == 30)
	}
}

Scoping(){
	class Sub{
		scoped()
		$.y = 20
		$.Proto = Base.extend()
		class Nest extends $.Proto{
			scoped()
			$.x = 10
			assert($.hasOwnProperty('x'))
			assert(!$.hasOwnProperty('y'))
			assert($.y == 20)
			$.y = 30
			assert($.y == 30)
			init(v){
				assert($.y == v)
			}
		}
		x = new Nest(30)
		assert(x.$.x == 10)
		assert($.y == 20)
		assert($.x === undefined)
	}
	assert($.Proto === undefined)
}

Super(){
	var order = ''
	class Role1{
		fn(a){ 
			order += '1' 
		}
	}
	class Role2{
		learn(Role1)
		fn(){
			order += '2'
			super()
		}
	}
	class Role3{
		fn(){
			order += '3'
			super()
		}
	}
	class Base{
		learn(Role2, Role3)
		fn(){
			order += '4'
			super()
		}
	}

	var base = new Base()
	base.fn()
	assert( order == '4321' )
}

Roles(){
	class Role1{ a = 20 }
	class Role2{ a = 30 }
	class Role3{ a = 40, b = 50 }
	class C1{ a = 10 }

	var x = new C1()
	C1.learn(Role1)
	C1.learn(Role2) 
	C1.learn(Role3)
	assert(x.a == 40)

	C1.forget(Role2)
	assert(x.a == 40)

	C1.forget(Role3)
	assert(x.a == 20)

	C1.forget(Role1)
	assert(x.a == 10)

	C1.learn(Role3)
	assert(x.a == 40)
	assert(x.b == 50)

	C1.forget(Role3)
	assert(x.b === undefined)

	class Proto1 extends Role1{}
	proto = new Proto1()
	proto.a == 20
	proto.hasOwnProperty('a') == false
	var p = Object.getPrototypeOf(proto)
	p.hasOwnProperty('a') == false
	p = Object.getPrototypeOf(p)
	p.hasOwnProperty('a') == true
}

Language(){

	// array splats
	var s1 = [1,2,3], s2 = [5,6,7]
	var s3 = [...s1, 4, ...s2, 8]

	assert(s3.join('') == '12345678')

	// argument splats
	func(){
		return [...]
	}
	assert(func(...s1,4,...s2, 8).join('') == '12345678')

	// member functions
	member(a){ return a + 10 }
	assert( member(10) == 20 )

	// arrow syntax
	arrow = a => a + 5
	assert(arrow(5) == 10)

	// destructuring assignment, and shorthand
	var t = 3
	var {x:{y:z,t:w}} = {x:{y:[5],t}}
	assert(z[0] == 5)
	assert(w == 3)

	// destructuring arguments
	desarg({x:y}){ return y }
	assert(desarg({x:5}) == 5)

	// default arguments
	defarg(x = 10){ return x }
	assert(defarg() == 10)
	assert(defarg(5) == 5)

	// rest arguments
	restarg(x, ...a){ return a[1] }
	assert(restarg(0,0,10) == 10)

	// switch
	var sw = 1
	switch(3){
		case 2: break;
		case 3: sw = 3; break;
	}
	assert(sw == 3)

	// try catch
	var ex = 0
	try{
		throw 3
	}
	catch(e){
		ex = e
	}
	assert( ex == 3 )

	// if else
	var ie = 0
	if(false) ie = 2
	else ie = 4
	assert(ie == 4)

	// do while
	var d = 5, c = 0
	do{
		c++
	}while(d-- > 0)
	assert(c == 6)

	// for in
	var obj = {x:1}
	var str = ''
	for(var k in obj) str += k
	assert( str == 'x' )

	// for of
	var array = [1,2,3,4]
	var str = ''
	for(var x of array) str += x
	assert(str == '1234')

	// for to
	var str = ''
	for(var x = 0 to 5) str += x
	assert(str == '01234')

	// for from
	var array = [1,2,3,4]
	var str = ''
	for(var x from array) str += x
	assert(str == '1234')

	// enum type
	enum mynum{
		x = 10
		y
	}
	assert(mynum.y == 11)

	// getter setter syntax
	class getset{
		var v
		get gs(){ return v }
		set gs(e){ v = e }
	}
	var val = getset{ gs = 20 }.gs
	assert( val == 20 )

	// const
	const cst = 10
	assert(cst == 10)

	// array comprehensions
	var arr = [for(var i = 0 to 4)i]
	assert(arr.join('') == '0123')

	// string templates
	var str = `12{1+1+1}4`
	assert(str == '1234')

	// bin and octal
	var bin = 0b1010
	var oct = 0o777
	assert(bin == 10)
	assert(oct == 511)

	// do catch
	test(a1, a2){
		return a1()+a2()
	}
	var ret = test() do v->3 catch v->4
	assert(ret == 7)

	// expression quoting
	var x = :5+4
	x.right.raw = undefined
	x.right.value = 5
	assert(eval(x) == 10)

	// expression templates
	var tmp = 10
	var y = :%tmp+10
	assert(eval(y) == 20)

	// multiline regex
	var rx = / / 
	hi|ho
	/ /g
	var [hi,ho] = "hiho".match(rx)
	assert(hi == 'hi')
	assert(ho == 'ho')

	// automatic * insertion
	var mul = 10
	var total = 100mul
	assert(total == 1000)

	// commas are optional
	arr = [
		1
		2
		3
	]
	obj = {
		x:1
		y:2
	}
	assert( arr.join('') == '123' )
	assert( obj.y == 2 )

	// logic words
	assert(true and true or not false)

	// existential object traverse
	var x = {a:{b:{c:10}}}
	var a = x?.a?.b?.c
	var b = x?.z?.w?.y
	assert(a == 10 && b === undefined)

	// existential assignment
	var c = undefined
	c ?= 10
	assert(c == 10)
	c ?= 20
	assert(c == 10)

	// existential prefix
	c = 1
	assert(?c)
	c = undefined
	assert(?c == false)
	
	// pow
	var p = 2**2
	assert(p == 4)

	// math modulus
	var p = -5%%3
	assert(p == 1)

	// integer divide	
	var p = 25%/10
	assert(p == 2)
}

// The test runner
var run = []
for(var key in this){
	var fn = this[key]
	if(typeof fn == 'function' && key.indexOf('no') != 0){
		run.push([key, fn])
	}
	if(key.indexOf('only') == 0){
		run = [key, fn]
		break
	}
}
for(var [name, fn] of run){
	out('Testing:'+name)
	Base{ fn() }
}