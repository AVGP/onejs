import math
import glscene
import diff
import chunked
import distfield2d

class EditImpl{

	// single cursor
	class Cursor extends Layer{

		constructor(text_layer){
			parent = this.text_layer = text_layer
			Layer::constructor()
			dontProxy('start','end','max')
			start = 0
			end = 0
			max = 0
			// denormalized positions
			ax = 0
			ay = 0
			w = 10
			x = 0

			// cursor that switches from pixel rendering to vector rendering depending on scale
			draw_cursor:(){
				var rel = mesh[].xy
				var dpdx = dFdx(rel)
				var dpdy = dFdy(rel)
				var edge = min(length(vec2(length(dpdx), length(dpdy))) * SQRT_1_2,1.)
				if(edge > 0.04){
					if(rel.x < dpdx.x) return vec4(#white,1.)
					return vec4(0.)
				}
				return vec4(#white, smoothstep(edge,-edge, box(rel, 0,0,0.1,1.)))
			}
			pixel:draw_cursor()
		}

		hideProperties()

		update(){
			// figure out where the cursor is going
			var rect = text_layer.cursorRect(end)
			x = rect.x
			y = rect.y
			h = rect.h
			// we have to generate some marker rects

			text_layer.clearMarkers()
			if(start != end){
				text_layer.addMarkers(start, end)
			}
			text_layer.updateText()
		}

		moveLeft(only_end){
			end = end - 1
			if(!only_end) start = end
			update()
			max = x
		}

		moveRight(only_end){
			end = end + 1
			if(!only_end) start = end
			update()
			max = x
		}

		moveUp(only_end, lines = 1){
			var rect = text_layer.cursorRect(end)
			end = text_layer.offsetFromPos(max, rect.y + .5*rect.h - lines * text_layer.line_height)
			if(!only_end) start = end
			update()
		}

		moveDown(only_end, lines = 1){
			var rect = text_layer.cursorRect(end)
			end = text_layer.offsetFromPos(max, rect.y + .5*rect.h + lines * text_layer.line_height)
			if(!only_end) start = end
			update()
		}

		moveTo(x, y, only_end){
			var off = text_layer.offsetFromPos(x, y)
			var change = end != off 
			end = off
			if(!only_end) change = start != end || change, start = end
			var r = text_layer.cursorRect(off)
			max = r.x
			if(change) update()
		}

		isSelection(){
			return start !== end
		}

		isCursor(){
			return start === end
		}
	}

	// cursor set 
	class Cursors{
		constructor(text_layer){
			list = [Cursor.new(text_layer)]
		}

		for(var key in Cursor) bind(key){
			if(typeof Cursor[key] == 'function'){
				this[key] = (){
					for(var cursor from list) cursor[key](...)
				}
			}
		}
	}

	constructor(){
		cursors = Cursors.new(text_layer || this)

		key.press(v)=>{
			out(v)
		}

		key.down(v)=>{
			var name = 'key' + v.name[0].toUpperCase() + v.name.slice(1)
			if(this[name]) this[name](v)
		}

		mouse.leftdown(v)=>{
			// set cursor start
			cursors.moveTo(mouse.x, mouse.y)
			mouse.capture() do =>{
				// move
				cursors.moveTo(mouse.x, mouse.y, true)

			}
		}

		cursors.moveDown(1, 100)
	}

	keyLeftarrow(){
		cursors.moveLeft(key.shift)
	}

	keyRightarrow(){
		cursors.moveRight(key.shift)
	}

	keyUparrow(){
		cursors.moveUp(key.shift)
	}

	keyDownarrow(){
		cursors.moveDown(key.shift)
	}
}

class Edit extends Text{
	load(EditImpl)
	constructor(){
		Text::constructor()
		EditImpl::constructor()
	}
}