import math
import glscene
import diff
import text_chunked
import distfield2d

class EditImpl{

	// single cursor
	class Cursor{
		constructor(cursors, id){
			this.cursors = cursors
			text_layer = cursors.text_layer
			this.id = id
			start = 0
			end = 0
			max = 0
		}
		
		hideProperties()

		moveLeft(only_end){
			end = end - 1
			if(!only_end) start = end
			max = text_layer.cursorRect(end).x
			cursors.update()
		}

		moveRight(only_end){
			end = end + 1
			if(!only_end) start = end
			max = text_layer.cursorRect(end).x
			cursors.update()
		}

		moveUp(only_end, lines = 1){
			var rect = text_layer.cursorRect(end)
			end = text_layer.offsetFromPos(max, rect.y + .5*rect.h - lines * text_layer.line_height)
			if(!only_end) start = end
			cursors.update()
		}

		moveDown(only_end, lines = 1){
			var rect = text_layer.cursorRect(end)
			end = text_layer.offsetFromPos(max, rect.y + .5*rect.h + lines * text_layer.line_height)
			if(!only_end) start = end
			cursors.update()
		}

		moveTo(x, y, only_end){
			var off = text_layer.offsetFromPos(x, y)
			var change = end != off 
			end = off
			if(!only_end) change = start != end || change, start = end
			var r = text_layer.cursorRect(off)
			max = r.x
			if(change) cursors.update()
		}

		isSelection(){
			return start !== end
		}

		isCursor(){
			return start === end
		}
	}

	// cursor set 
	class Cursors{
		constructor(text_layer){
			this.text_layer = text_layer
			list = [Cursor.new(this, 0)]
		}

		update(){
			if(pending) return
			pending = 1
			setImmediate() do()=>{
				pending = 0
				text_layer.clearMarkers()
				text_layer.clearCursors()
				// lets update all our render things.
				for(var cursor from list){
					if(cursor.start != cursor.end){
						text_layer.addMarkers(cursor.start, cursor.end)
					}
					text_layer.addCursor(cursor.end)
				}
			}
		}

		add(){
			var cursor = Cursor.new(this,list.length)
			list.push(cursor)
			return cursor
		}
		// forwards the whole api
		for(var key in Cursor) bind(key){
			if(typeof Cursor[key] == 'function'){
				this[key] = (){
					for(var cursor from list) cursor[key](...)
				}
			}
		}
	}

	constructor(){
		cursors = Cursors.new(text_layer || this)

		key.press(v)=>{
			out(v)
		}

		key.down(v)=>{
			var name = 'key' + v.name[0].toUpperCase() + v.name.slice(1)
			if(this[name]) this[name](v)
		}

		mouse.leftdown(v)=>{
			// set cursor start
			// if we are doing a meta-click-drag we need to add a cursor
			// if we are doing an alt-drag we need to (add?) create cursors
			// in a rectangle
			if(key.leftmeta || key.rightmeta){
				var cursor = cursors.add()
				
				// in that case what we need to 
				cursor.moveTo(mouse.x, mouse.y)
				mouse.capture() do =>{
					// move
					cursor.moveTo(mouse.x, mouse.y, true)
				}
			}
			else{
				// in that case what we need to 
				cursors.moveTo(mouse.x, mouse.y)
				mouse.capture() do =>{
					// move
					cursors.moveTo(mouse.x, mouse.y, true)
				}
			}
		}

		cursors.moveDown(1, 100)
	}

	keyLeftarrow(){
		cursors.moveLeft(key.shift)
	}

	keyRightarrow(){
		cursors.moveRight(key.shift)
	}

	keyUparrow(){
		cursors.moveUp(key.shift)
	}

	keyDownarrow(){
		cursors.moveDown(key.shift)
	}
}

class Edit extends Text{
	load(EditImpl)
	constructor(){
		Text::constructor()
		EditImpl::constructor()
	}
}