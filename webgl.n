import math
import track

// super basic meshgens
vec2Rect( x, y, w, h ){
	return vec2[6](
		x,y,   x+w,y,   x,y+h
		x+w,y, x+w,y+h, x,y+h
	)
}

vec3Rect( x, y, w, h, z = 0 ){
	return vec3[6](
		x,y,z,   x+w,y,z,   x,y+h,z
		x+w,y,z, x+w,y+h,z, x,y+h,z
	)
}

vec4Rect( x, y, w, h, z = 0, ww = 1 ){
	return vec4[6](
		x,y,z,ww,   x+w,y,z,ww,   x,y+h,z,ww
		x+w,y,z,ww, x+w,y+h,z,ww, x,y+h,z,ww
	)
}

class Node extends Proxy{

	// make a singleton copy of Time
	this.Time = Time{}

	// API available in draw
	clearAll:( vec3 col ){
		gl.clearColor(col[0], col[1], col[2], 1.0)
		gl.colorMask(true, true, true, true)
		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)
	}

	clearAll_:( vec4 col ){
		gl.clearColor(col[0], col[1], col[2], col[3])
		gl.colorMask(true, true, true, true)
		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)
	}
	
	drawChildren:(){
		if(child) for(var c from child) c.draw()
	}
	
	
	lockBuffer_:(){
		return lockBuffer(gl.width, gl.height)
	}

	lockBuffer:(width, height){
		var buffers = gl._buffers || (gl._buffers = {})
		var id = '_' + width + '_' + height
		var buf_array = buffers[id]
		if(!buf_array) buf_array = buffers[id] = []
	
		var buf = buf_array.pop()
		if(!buf){
			buf = gl.createFramebuffer()
			var tex = buf.tex = gl.createTexture()
			gl.bindTexture(gl.TEXTURE_2D, tex)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
			buf.width = width
			buf.height = height
			buf.loaded = true
		}
		return buf
	}

	releaseBuffer:(buf){
		var buffers = gl._buffers || (gl._buffers = {})
		var id = '_' + buf.width + '_' + buf.height
		var buf_array = buffers[id]
		buf_array.push(buf)
	}

	pushBuffer:(buf){
		if(!gl._bufstack) gl._bufstack = []
		gl._bufstack.push(buf)
		gl.bindFramebuffer(gl.FRAMEBUFFER, buf)
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, buf.tex, 0)
		gl.viewport(0, 0, buf.width, buf.height)
	}

	popBuffer:(){
		gl._bufstack.pop()
		if(gl._bufstack.length){
			var buf = gl._bufstack[gl._bufstack.length - 1]
			gl.bindFramebuffer(gl.FRAMEBUFFER, buf)
			gl.frameBufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, buf.tex, 0)
			gl.viewport(0, 0, buf.width, buf.height)
		}
		else{
			gl.bindFramebuffer(gl.FRAMEBUFFER, null)
			gl.bindTexture(gl.TEXTURE_2D, null)
			gl.viewport(0, 0, gl.width, gl.height)
		}
	}

	// default draw
	draw:(){
		drawSelf()
	}

	init:(){
		if(!owner.child) owner.child = []
		owner.child.push(this)
		gl = owner.gl
	}

	blend: alpha * pixel + (1 - alpha) * frame

	depth: pixel < frame

	stencil: true

	// the proxy code generator
	proxy(){
		// so lets stringify it.
		var code = draw.proxy_code
		if(code) return Proxy::proxy() + code

		code = ''

		var ast = draw
		// make a fresh scope and signals store
		var js = this.GenDrawJS
		js.new_state()
		// plug the module of the ast node
		js.module = ast.module
		js.context = this
		js.proxy_props = proxy_props = {}
		js.proxy_refs = proxy_refs = {'owner':{}}

		js.uid = 0
		if(ast.type != 'Function') throw new Error('GL Draw not a function')
		
		var flags = js.pull_flags(ast)
		profile(1) do ->
		code += 'this.draw = ' + js.Function(ast, undefined, [], undefined, ['gl']) + '\n'

		// we have to generate redraw binding code for proxy_bind
		var rem = 'this.remove = function(){\n'

		for(var ref in proxy_refs){
			var props = proxy_refs[ref]
			for(var prop in props){
				var pname = 'this.' + ref + '.' + prop
				code += 'if(' + pname + '_hook)' + pname + '_hook(this)\n'
				rem += '\tif(' + pname + '_unhook)' + pname + '_unhook(this)\n'
			}
		}
		rem += '}\n'
		code += rem

		if(flags.indexOf('js') != -1) out(code)
		
		// prepend static type_methods
		for(var k in js.type_methods){
			code = js.type_methods[k] + '\n'+ code
		}

		draw.proxy_remote = code

		if(dump) console.log(code)

		return Proxy::proxy() + code
	}

	type: triangle

	var glsl_variables = {
		gl_PointCoord:vec2
		gl_FrontFacing:bool
		gl_FragCoord:vec4
		gl_Position:vec4
		gl_PointSize:float
		gl_ClipDistance:float
		gl_VertexID:int
		gl_InstanceID:int
		gl_MaxVertexAttribs:int
		gl_MaxVertexUniformVectors:int
		gl_MaxVaryingVectors:int
		gl_MaxVertexTextureImageUnits:int
		gl_MaxCombinedTextureImageUnits:int
		gl_MaxTextureImageUnits:int
		gl_MaxFragmentUniformVectors:int
		gl_MaxDrawBuffers:int
	}

	enum glsl_types{
		half, float, double, short, long, int
		mat2, mat3, mat4
		vec2, vec3, vec4
		ivec2, ivec3, ivec4
		bvec2, bvec3, bvec4
		hvec2, hvec3, hvec4
		dvec2, dvec3, dvec4
		fvec2, fvec3, fvec4
		sampler2D
		samplerCube
	}
	
	enum glsl_functions{
		sizeof, radians, degrees
		sin, cos, tan
		asin, acos, atan, 
		pow, exp, log, exp2, log2
		sqrt, inversesqrt
		abs, sign, floor, ceil, fract
		mod, min, max, clamp
		mix, step, smoothstep
		length, distance
		dot, cross, normalize
		faceforward, reflect, refract
		matrixCompMult
		lessThan, lessThanEqual
		greaterThan, greaterThanEqual
		equal, notEqual
		any, all, not
		texture2DLod
		texture2DProjLod
		textureCubeLod
		texture2D
		texture2DProj
		textureCube
	}
	
	var glc = {
		DEPTH_BUFFER_BIT:0x100,STENCIL_BUFFER_BIT:0x400,COLOR_BUFFER_BIT:0x4000,
		
		POINTS:0x0,LINES:0x1,LINE_LOOP:0x2,LINE_STRIP:0x3,TRIANGLES:0x4,TRIANGLE_STRIP:0x5,TRIANGLE_FAN:0x6,
		
		ZERO:0x0,ONE:0x1,SRC_COLOR:0x300,ONE_MINUS_SRC_COLOR:0x301,SRC_ALPHA:0x302,ONE_MINUS_SRC_ALPHA:0x303,DST_ALPHA:0x304,ONE_MINUS_DST_ALPHA:0x305,
		DST_COLOR:0x306,ONE_MINUS_DST_COLOR:0x307,SRC_ALPHA_SATURATE:0x308,FUNC_ADD:0x8006,BLEND_EQUATION:0x8009,
		
		BLEND_EQUATION_RGB:0x8009,BLEND_EQUATION_ALPHA:0x883d,FUNC_SUBTRACT:0x800a,FUNC_REVERSE_SUBTRACT:0x800b,
		BLEND_DST_RGB:0x80c8,BLEND_SRC_RGB:0x80c9,BLEND_DST_ALPHA:0x80ca,BLEND_SRC_ALPHA:0x80cb,CONSTANT_COLOR:0x8001,
		ONE_MINUS_CONSTANT_COLOR:0x8002,CONSTANT_ALPHA:0x8003,ONE_MINUS_CONSTANT_ALPHA:0x8004,BLEND_COLOR:0x8005,
		
		ARRAY_BUFFER:0x8892,ELEMENT_ARRAY_BUFFER:0x8893,ARRAY_BUFFER_BINDING:0x8894,ELEMENT_ARRAY_BUFFER_BINDING:0x8895,

		STREAM_DRAW:0x88e0,STATIC_DRAW:0x88e4,DYNAMIC_DRAW:0x88e8,BUFFER_SIZE:0x8764,BUFFER_USAGE:0x8765,

		CURRENT_VERTEX_ATTRIB:0x8626,FRONT:0x404,BACK:0x405,FRONT_AND_BACK:0x408,
		
		TEXTURE_2D:0xde1,CULL_FACE:0xb44,
		
		BLEND:0xbe2,DITHER:0xbd0,STENCIL_TEST:0xb90,DEPTH_TEST:0xb71,SCISSOR_TEST:0xc11,POLYGON_OFFSET_FILL:0x8037,

		SAMPLE_ALPHA_TO_COVERAGE:0x809e,SAMPLE_COVERAGE:0x80a0,NO_ERROR:0x0,
		
		INVALID_ENUM:0x500,INVALID_VALUE:0x501,
		
		INVALID_OPERATION:0x502,OUT_OF_MEMORY:0x505,
		
		CW:0x900,CCW:0x901,LINE_WIDTH:0xb21,ALIASED_POINT_SIZE_RANGE:0x846d,
		ALIASED_LINE_WIDTH_RANGE:0x846e,
		
		CULL_FACE_MODE:0xb45,FRONT_FACE:0xb46,
		
		DEPTH_RANGE:0xb70,DEPTH_WRITEMASK:0xb72,
		DEPTH_CLEAR_VALUE:0xb73,DEPTH_FUNC:0xb74,
		
		STENCIL_CLEAR_VALUE:0xb91,STENCIL_FUNC:0xb92,STENCIL_FAIL:0xb94,
		STENCIL_PASS_DEPTH_FAIL:0xb95,STENCIL_PASS_DEPTH_PASS:0xb96,STENCIL_REF:0xb97,STENCIL_VALUE_MASK:0xb93,
		STENCIL_WRITEMASK:0xb98,STENCIL_BACK_FUNC:0x8800,STENCIL_BACK_FAIL:0x8801,STENCIL_BACK_PASS_DEPTH_FAIL:0x8802,
		STENCIL_BACK_PASS_DEPTH_PASS:0x8803,STENCIL_BACK_REF:0x8ca3,STENCIL_BACK_VALUE_MASK:0x8ca4,
		STENCIL_BACK_WRITEMASK:0x8ca5,
		
		VIEWPORT:0xba2,SCISSOR_BOX:0xc10,COLOR_CLEAR_VALUE:0xc22,COLOR_WRITEMASK:0xc23,
		
		UNPACK_ALIGNMENT:0xcf5,PACK_ALIGNMENT:0xd05,
		
		MAX_TEXTURE_SIZE:0xd33,MAX_VIEWPORT_DIMS:0xd3a,

		SUBPIXEL_BITS:0xd50,RED_BITS:0xd52,GREEN_BITS:0xd53,BLUE_BITS:0xd54,ALPHA_BITS:0xd55,DEPTH_BITS:0xd56,STENCIL_BITS:0xd57,

		POLYGON_OFFSET_UNITS:0x2a00,POLYGON_OFFSET_FACTOR:0x8038,TEXTURE_BINDING_2D:0x8069,
		
		SAMPLE_BUFFERS:0x80a8,SAMPLES:0x80a9,SAMPLE_COVERAGE_VALUE:0x80aa,SAMPLE_COVERAGE_INVERT:0x80ab,
		
		COMPRESSED_TEXTURE_FORMATS:0x86a3,
		DONT_CARE:0x1100,FASTEST:0x1101,NICEST:0x1102,GENERATE_MIPMAP_HINT:0x8192,
		
		BYTE:0x1400,UNSIGNED_BYTE:0x1401,
		SHORT:0x1402,UNSIGNED_SHORT:0x1403,INT:0x1404,UNSIGNED_INT:0x1405,FLOAT:0x1406,DEPTH_COMPONENT:0x1902,
		ALPHA:0x1906,RGB:0x1907,RGBA:0x1908,LUMINANCE:0x1909,LUMINANCE_ALPHA:0x190a,UNSIGNED_SHORT_4_4_4_4:0x8033,
		UNSIGNED_SHORT_5_5_5_1:0x8034,UNSIGNED_SHORT_5_6_5:0x8363,
		
		FRAGMENT_SHADER:0x8b30,VERTEX_SHADER:0x8b31,
		
		MAX_VERTEX_ATTRIBS:0x8869,MAX_VERTEX_UNIFORM_VECTORS:0x8dfb,MAX_VARYING_VECTORS:0x8dfc,
		MAX_COMBINED_TEXTURE_IMAGE_UNITS:0x8b4d,MAX_VERTEX_TEXTURE_IMAGE_UNITS:0x8b4c,MAX_TEXTURE_IMAGE_UNITS:0x8872,
		MAX_FRAGMENT_UNIFORM_VECTORS:0x8dfd,SHADER_TYPE:0x8b4f,DELETE_STATUS:0x8b80,LINK_STATUS:0x8b82,
		VALIDATE_STATUS:0x8b83,ATTACHED_SHADERS:0x8b85,ACTIVE_UNIFORMS:0x8b86,ACTIVE_ATTRIBUTES:0x8b89,
		SHADING_LANGUAGE_VERSION:0x8b8c,CURRENT_PROGRAM:0x8b8d,NEVER:0x200,LESS:0x201,EQUAL:0x202,LEQUAL:0x203,
		GREATER:0x204,NOTEQUAL:0x205,GEQUAL:0x206,ALWAYS:0x207,KEEP:0x1e00,REPLACE:0x1e01,INCR:0x1e02,DECR:0x1e03,
		INVERT:0x150a,INCR_WRAP:0x8507,DECR_WRAP:0x8508,VENDOR:0x1f00,RENDERER:0x1f01,VERSION:0x1f02,NEAREST:0x2600,
		
		LINEAR:0x2601,NEAREST_MIPMAP_NEAREST:0x2700,LINEAR_MIPMAP_NEAREST:0x2701,NEAREST_MIPMAP_LINEAR:0x2702,
		LINEAR_MIPMAP_LINEAR:0x2703,TEXTURE_MAG_FILTER:0x2800,TEXTURE_MIN_FILTER:0x2801,TEXTURE_WRAP_S:0x2802,
		
		TEXTURE_WRAP_T:0x2803,TEXTURE:0x1702,TEXTURE_CUBE_MAP:0x8513,TEXTURE_BINDING_CUBE_MAP:0x8514,
		TEXTURE_CUBE_MAP_POSITIVE_X:0x8515,TEXTURE_CUBE_MAP_NEGATIVE_X:0x8516,TEXTURE_CUBE_MAP_POSITIVE_Y:0x8517,
		TEXTURE_CUBE_MAP_NEGATIVE_Y:0x8518,TEXTURE_CUBE_MAP_POSITIVE_Z:0x8519,TEXTURE_CUBE_MAP_NEGATIVE_Z:0x851a,
		
		MAX_CUBE_MAP_TEXTURE_SIZE:0x851c,TEXTURE0:0x84c0,TEXTURE1:0x84c1,TEXTURE2:0x84c2,TEXTURE3:0x84c3,TEXTURE4:0x84c4,
		
		TEXTURE5:0x84c5,TEXTURE6:0x84c6,TEXTURE7:0x84c7,TEXTURE8:0x84c8,TEXTURE9:0x84c9,TEXTURE10:0x84ca,TEXTURE11:0x84cb,
		TEXTURE12:0x84cc,TEXTURE13:0x84cd,TEXTURE14:0x84ce,TEXTURE15:0x84cf,TEXTURE16:0x84d0,TEXTURE17:0x84d1,
		TEXTURE18:0x84d2,TEXTURE19:0x84d3,TEXTURE20:0x84d4,TEXTURE21:0x84d5,TEXTURE22:0x84d6,TEXTURE23:0x84d7,
		TEXTURE24:0x84d8,TEXTURE25:0x84d9,TEXTURE26:0x84da,TEXTURE27:0x84db,TEXTURE28:0x84dc,TEXTURE29:0x84dd,
		TEXTURE30:0x84de,TEXTURE31:0x84df,ACTIVE_TEXTURE:0x84e0,REPEAT:0x2901,CLAMP_TO_EDGE:0x812f,MIRRORED_REPEAT:0x8370,
		
		FLOAT_VEC2:0x8b50,FLOAT_VEC3:0x8b51,FLOAT_VEC4:0x8b52,INT_VEC2:0x8b53,INT_VEC3:0x8b54,INT_VEC4:0x8b55,BOOL:0x8b56,
		BOOL_VEC2:0x8b57,BOOL_VEC3:0x8b58,BOOL_VEC4:0x8b59,FLOAT_MAT2:0x8b5a,FLOAT_MAT3:0x8b5b,FLOAT_MAT4:0x8b5c,
		
		SAMPLER_2D:0x8b5e,SAMPLER_CUBE:0x8b60,VERTEX_ATTRIB_ARRAY_ENABLED:0x8622,VERTEX_ATTRIB_ARRAY_SIZE:0x8623,
		
		VERTEX_ATTRIB_ARRAY_STRIDE:0x8624,VERTEX_ATTRIB_ARRAY_TYPE:0x8625,VERTEX_ATTRIB_ARRAY_NORMALIZED:0x886a,
		VERTEX_ATTRIB_ARRAY_POINTER:0x8645,VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:0x889f,COMPILE_STATUS:0x8b81,LOW_FLOAT:0x8df0,
		
		MEDIUM_FLOAT:0x8df1,HIGH_FLOAT:0x8df2,LOW_INT:0x8df3,MEDIUM_INT:0x8df4,HIGH_INT:0x8df5,FRAMEBUFFER:0x8d40,
		
		RENDERBUFFER:0x8d41,RGBA4:0x8056,RGB5_A1:0x8057,RGB565:0x8d62,DEPTH_COMPONENT16:0x81a5,STENCIL_INDEX:0x1901,
		
		STENCIL_INDEX8:0x8d48,DEPTH_STENCIL:0x84f9,
		
		RENDERBUFFER_WIDTH:0x8d42,RENDERBUFFER_HEIGHT:0x8d43,
		RENDERBUFFER_INTERNAL_FORMAT:0x8d44,RENDERBUFFER_RED_SIZE:0x8d50,RENDERBUFFER_GREEN_SIZE:0x8d51,
		RENDERBUFFER_BLUE_SIZE:0x8d52,RENDERBUFFER_ALPHA_SIZE:0x8d53,RENDERBUFFER_DEPTH_SIZE:0x8d54,
		RENDERBUFFER_STENCIL_SIZE:0x8d55,
		
		FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:0x8cd0,FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:0x8cd1,
		FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:0x8cd2,FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:0x8cd3,
		COLOR_ATTACHMENT0:0x8ce0,DEPTH_ATTACHMENT:0x8d00,STENCIL_ATTACHMENT:0x8d20,DEPTH_STENCIL_ATTACHMENT:0x821a,
		NONE:0x0,FRAMEBUFFER_COMPLETE:0x8cd5,FRAMEBUFFER_INCOMPLETE_ATTACHMENT:0x8cd6,
		FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:0x8cd7,FRAMEBUFFER_INCOMPLETE_DIMENSIONS:0x8cd9,
		FRAMEBUFFER_UNSUPPORTED:0x8cdd,FRAMEBUFFER_BINDING:0x8ca6,RENDERBUFFER_BINDING:0x8ca7,

		MAX_RENDERBUFFER_SIZE:0x84e8,INVALID_FRAMEBUFFER_OPERATION:0x506,UNPACK_FLIP_Y_WEBGL:0x9240,
		UNPACK_PREMULTIPLY_ALPHA_WEBGL:0x9241,CONTEXT_LOST_WEBGL:0x9242,UNPACK_COLORSPACE_CONVERSION_WEBGL:0x9243,
		BROWSER_DEFAULT_WEBGL:0x9244		
	}
	
	var glsl_uniform_map = {
		float: 'uniform1f'
		int:   'uniform1i'
		vec2:  'uniform2f'
		vec3:  'uniform3f'
		vec4:  'uniform4f'
	}
	
	var glsl_uniform_matrix = {
		mat2: 'uniformMatrix2fv'
		mat3: 'uniformMatrix3fv'
		mat4: 'uniformMatrix4fv'
	}
	
	var glsl_compare = {
		'<':glc.LESS
		'<=':glc.LEQUAL
		'>':glc.GREATER
		'>=':glc.GEQUAL
		'!==':glc.NOTEQUAL
		'!=':glc.NOTEQUAL
		'==':glc.EQUAL
		'===':glc.EQUAL
	}

	class DepTraceGLSL extends AST.Walk{

		// unsupported keys
		ForIn( n ){ throw new Error('Cannot use for in in a shader, use for from') }
		ForOf( n ){ throw new Error('Cannot use for of in a shader, use for from') }
		Struct( n ){ throw new Error('Cannot use struct in a shader function') }
		Comprehension( n ){ throw new Error('Cannot use a comprehension in a shader function') }
		ThisCall( n ){ throw new Error('Cannot use this in a shader function') }
		Template( n ){ throw new Error('Cannot use templates in a shader function') }
		Throw( n ){ throw new Error('Cannot use throw in a shader function') }
		Try( n ){ throw new Error('Cannot use try in a shader function') }
		Enum( n ){ throw new Error('Cannot use enum in a shader function') }
		Define( n ){ throw new Error('Cannot define in a shader function') }
		New( n ){ throw new Error('Cannot use new in a shader function') }
		Nest( n ){ throw new Error('Cannot use nesting syntax in a shader function') }
		Class( n ){ throw new Error('Cannot define a class in a shader function') }
		Quote( n ){ throw new Error('Cannot use quote in a shader function') }
		Rest( n ){ throw new Error('Cannot use rest ... in a shader function') }
		Then( n ){ throw new Error('Cannot use then in a shader function') }
		Debugger( n ){ throw new Error('Cannot use debuger in a shader function') }
		With( n ){ throw new Error('Cannot use with in a shader function') }

		// causes dependency marks to travel up the tree
		// uniform has mark 1
		// attribute has mark 2
		// pixel has mark 3
		Pre( n ){
			n.infer = undefined
			n.mark = undefined
		}

		Post( n, overload_mark ){
			// propagate mark and inference up the chain
			var parent = n.parent
			var nmark = overload_mark || n.mark
			if(parent){
				if(nmark){
					var pmark = parent.mark
					if(!pmark) parent.mark = nmark
					else if(pmark < nmark) parent.mark = nmark
				}
				if(!parent.infer) parent.infer = n.infer
			}
		}

		// i must dry implement Do
		Do( n, parent ){
			n.parent = parent
			Pre(n)
			AST.Walk::Do(n, parent)
			// fuse mark properly
			if(n.arg.mark > n.call.mark) n.call.mark = n.arg.mark
		}

		Value( n, parent ){
			n.parent = parent
			Pre(n)
			if(n.kind == 'string'){ // image
				// load Image.new() and store it
				var name = 'img_'+n.raw.replace(/[^\w]/g,'_')
				if(!context[name]){
					context[name] = Image.new(n.raw)

				}
			}
			else
			if(n.kind != 'num') throw new Error('Only numeric values supported')
			if(n.raw.indexOf('.') != -1) n.infer = float
			else n.infer = int
			Post(n)
		}

		For( n, parent ){
			var old_scope = scope
			var old_marks = marks
			scope = Object.create(scope)
			marks = Object.create(marks)
			AST.Walk::For(n, parent)
			scope = old_scope
			marks = old_marks
			n.for_mark = n.mark
			AST.Walk::For(n, parent)
		}

		ForTo( n, parent ){
			var old_scope = scope
			var old_marks = marks
			scope = Object.create(scope)
			marks = Object.create(marks)
			AST.Walk::ForTo(n, parent) // first walk
			scope = old_scope
			marks = old_marks
			n.for_mark = n.mark // store mark
			AST.Walk::ForTo(n, parent) // second walk
		}

		ForFrom( n, parent ){
			if(n.left.type != 'Var' || n.left.defs.length != 1) throw new Error('Shaders only support for(var value from fixedarray)')
			var old_scope = scope
			var old_marks = marks
			scope = Object.create(scope)
			marks = Object.create(marks)
			AST.Walk::ForFrom(n, parent)
			scope = old_scope
			marks = old_marks
			n.for_mark = n.mark
			AST.Walk::ForFrom(n, parent)
		}

		Id( n, parent ){
			n.parent = parent
			Pre(n)
			var name = n.name
			if(n.flag == 35){
				n.infer = vec3
				return Post(n)// is color
			}

			if(macro_args && macro_args[name]){
				var type = macro_args[name].infer
				n.infer = type
				return Post(n)
			}

			if(scope && scope[name]){
				var type = scope[name]
				n.infer = type
				n.mark = marks[name]
				return Post(n)
			}

			var type = glsl_variables[name]
			if(type){
				if(name == 'gl_FragCoord') n.mark = 3
				n.infer = type
				return Post(n)
			}

			// static type method or property?
			var type = find_type(name)
			if(type){
				n.infer = type
				return Post(n)
			}

			// check if we are a macro?
			var def = this.find_define(name)
			if(def){
				this[def.type](def, n)
				return Post(n)
			}

			// lets resolve name
			var prop = context[name]
			if(prop === undefined) throw new Error('Cannot resolve ' + name)
			
			// what if we are a type
			// we are a reference to a remote object
			if(prop.proxy_uid){

				// what if we reference a texture here?
				if(prop._sampler2D_){
					n.mark = 2 // atleast a vertex shader
				}
				n.infer = {
					name:'object'
					ref_name: name
					ref:prop
				}
				return Post(n)
			}
			if(prop._ast_){
				// what if we are a normal property with a value?..
				// we will need to 
				//if(!prop.value._ast_) throw new Error('invalid property ' + name)
				// we have a bind
				// check if its a value, or a fully static type constructor
				if(prop.type == 'Value'){
					if(prop.kind != 'num') throw new Error('invalid type in DepTraceGLSL ' + prop.kind)
					n.mark = prop.mark = 1
					n.infer = prop.infer = float
					// lets replace the property with the actual value.
					context[name] = prop//prop.value = prop.value.value
					// unbind the expression
					//prop.value = undefined
				}
				else {
					// if we reference a property more than once
					// we need to store it in a temp variable
					if(this.refcount[name]) this.refcount[name]++
					else this.refcount[name] = 1
					var mod = this.module
					this.module = prop.module
					this[prop.type](prop, n)
					this.module = mod
				}
			}
			else {
				//TODO turn properties into signals here!
				//log(prop)

				// its a placeholder class
				if(prop.hasOwnProperty('__class__')){
					n.infer = {
						name:'object'
						ref_name: name
						ref:prop
					}
					return Post(n)
				}

				if(typeof prop == 'object' && typeof prop.t == 'object'){
					n.mark = 1
					n.infer = prop.t
				} 
				else if(typeof prop == 'number'){
					n.mark = 1
					n.infer = float
				}
				else throw new Error('Add other property types ' + name)
			}
			if(n.kind){
				// lets set our 'infer' to this type
				if(n.kind.name == 'pixel'){
					n.mark = 3	// mark us as pixel
				}
				else if(n.kind.name == 'vertex'){
					n.mark = 2
				}
				else {
					// where do we get our typemap?
					n.infer = module.types[n.kind.name]
					if(!n.infer) throw new Error('cannot find type ' + n.kind.name)
				}
			}
			Post(n)
		}

		Index( n, parent ){
			n.parent = parent
			Pre(n)
			if(!n.index){
				var nmark = n.mark = 2 // mark as attribute
				if(n.object.kind && n.object.kind.name == 'pixel')
					nmark = 3

				// what is our our type however?..
				var attrib = context[n.object.name]
				if(!attrib) throw new Error('cannot fetch attribute '+n.object.name)

				n.infer = attrib.t

				return Post(n, nmark)
			}
			else{ // we are an index
				// resolve the object
				this[n.object.type](n.object, n)

				// resolve the index
				this[n.index.type](n.index, n)

				// we have to have an inferred type on object now
				if(!n.infer) throw new Error('index access without type')
				if(!n.infer.dim) throw new Error('index access on type without dimensions')
				n.infer = Object.getPrototypeOf(n.infer) // rip off dimensions

				return Post(n)
			}
			return AST.Walk::Index(n)
		}
		
		Key( n, parent ){
			n.parent = parent
			Pre(n)

			// only try to walk/resolve the object
			this[n.object.type](n.object, n)
			var nmark = n.mark

			// remote object
			if(n.object.infer.name == 'object'){

				var obj = n.object.infer.ref
				// make a reference to another object.key
				var propname = n.key.name
				var prop = obj[propname]

				if(prop === undefined) throw new Error('Cannot find ' + n.object.name + '.' + propname)

				// mark signal in our proxy table
				n.infer = prop && prop.t || float
				n.mark = 1 // uniform

				// flag ourself in proxy_refs
				var objname = n.object.name
				var bind = proxy_refs[objname] || (proxy_refs[objname] = {})
				bind[propname] = 1

				// flag it for the dependency codegen
				n.remote = 1
				return Post(n)
			}

			if(n.object.type == 'Index' && !n.object.index && !(n.object.infer.name in glsl_types)){
				// extend our vertex shader mark upwards one step, since we are not splittable here
				if(n.mark == 3) nmark = 3, n.mark = 2
			}

			// we have to have an inferred type on object now
			if(!n.infer) throw new Error('key access without type')
			
			var fields = n.infer.fields
			if(!fields) throw new Error('key access on type without fields')

			var key_name = n.key.name

			if(key_name == 'length' && n.infer.dim){
				n.const_length = n.infer.dim
				n.mark = undefined
				n.infer = int
				return Post(n)
			}
			var type = fields[key_name]
			if(!type && n.object.infer.name in glsl_types){
				// validate swizzlingl. this code must deserve a prize.
				var swiz = check_swizzle( key_name, n.object.infer.slots )
				if(swiz){
					if(swiz.length == 2) type = vec2
					else if(swiz.length  == 3) type = vec3
					else if(swiz.length  == 4) type = vec4
				}
			}
			if(!type) throw new Error('type '+n.object.infer.name+' has no field ' + key_name)

			n.infer = type
			
			return Post(n, nmark)
		}

		this.Function( n, parent ){
			// we should only do our body, not our params
			n.parent = parent
			//Pre(n)
			var body = n.body
			if(body) this[body.type](body, n)
			//Post(n)
		}

		Def( n, parent ){
			n.parent = parent
			var type
			var mark
			// dont let the mark travel up
			var oldmark = n.mark
			if(n.init) this[n.init.type](n.init, n)
			if(oldmark > n.mark || n.mark === undefined) n.mark = oldmark

			// fetch our mark from for loop
			var in_for
			var for_node
			if(for_node = n.parent.parent){
				if(for_node.type == 'ForFrom' || for_node.type == 'ForTo' || for_node.type == 'For'){
					if(n.parent.defs.length > 1) throw new Error('Cannot define more than one var in a for')
					if(for_node.for_mark) n.mark = for_node.for_mark
					in_for = true
				}
			}

			if(n.parent.type == 'Var'){
				if(!n.init){
					if(for_node && for_node.type == 'ForFrom'){
						// the type is inferred from the right hand side
						type = for_node.right.infer
						if(!type.dim) throw new Error('Cannot for from over dimensionless type ' + type.name)
						type = Object.getPrototypeOf(type)
					}
					else throw new Error('Cannot use uninitialized var')
				}
				else{
					type = n.init.infer
					if(in_for && type.name == 'float') type = int
				}
			}
			else if(n.parent.type === 'TypeVar'){
				var kind = n.parent.kind
				if(kind.type == 'Index'){
					var name = kind.object.name
					var type = this.find_type(name)
					type = Object.create(type)
					type.dim = 1
				}
				else{
					var name = kind.name
					type = this.find_type(name)
				}
			}
			else throw new Error('Unsupported Def encountered')
			n.infer = scope[n.id.name] = type
			marks[n.id.name] = n.mark
		}

		Return( n, parent ){
			// set return type
			n.parent = parent
			Pre(n)
			if(n.arg){
				var oldmark = n.mark
				this[n.arg.type](n.arg, n)
				if(oldmark > n.mark || n.mark === undefined) n.mark = oldmark
			}
			if(return_type && return_type != n.infer){
				throw new Error('Multiple return types detected '+return_type.name + ' and ' + n.infer)
			}
			return_type = n.infer
			Post(n)
		}

		// type inference implementation of texture2D
		compiler_texture2D( n, parent ){

			var args = n.args
			if(args.length < 2) throw new Error('texture2D not enough arguments')
			// the first arg is the sampler2D we are going to need.

			var sampler = args[0]
			var sampler_name 
			if(sampler.type == 'This'){
				sampler_name = context_name
				sampler.infer = {
					object:context,
					name:'object'
				}
			}
			else{
				sampler_name = sampler.name
				this[sampler.type](sampler, n)

				if(sampler.infer.name != 'object' || !sampler.infer.ref._sampler2D_)
					throw new Error('texture2D invalid first argument type ' + sampler.infer.name)
			}

			var pos = args[1]
			this[pos.type](pos, n)
			if(pos.infer.name != 'vec2')
				throw new Error('texture2D invalid second argument type ' + pos.infer.name)

			// optional 3rd arg
			var bias = n.args[2]
			if(bias && bias.type != 'Object'){
				this[bias.type](bias, n)
			}
			
			if(!proxy_refs[sampler_name]) proxy_refs[sampler_name] = {}

			if(n.mark != 3) n.mark = 2
			n.infer = vec4
			Post(n)
		}

		// type inference calls
		Call( n, parent ){
			n.parent = parent
			Pre(n)

			// static type methods
			if(n.fn.type == 'Key'){
				var obj = n.fn.object
				if(obj.type == 'Id'){
					var name = obj.name
					if(name == 'Math'){
						n.infer = float
						return Post(n)
					}
					var type = this.find_type(name)
					if(type){
						// static method call
						for(var arg from n.args) this[arg.type](arg, n)
						n.infer = type
						return Post(n)
					}
				}
			}

			if(n.fn.type == 'Key'){ // type infer the object
				n.fn.parent = n
				this[n.fn.object.type](n.fn.object, n.fn)
			}
			else if(context[n.fn.name] && !context[n.fn.name]._ast_){
				this[n.fn.type](n.fn, n)
			}

			// we are an id, or an id on an object.
			if(n.fn.type == 'Id' || n.fn.type == 'Key' && n.fn.object.infer && n.fn.object.infer.name == 'object'){

				// check 
				var name
				var new_context
				if(n.fn.type == 'Id'){
					name = n.fn.name

					//!HACK todo fix this
					if(name == 'length'){
						for(var arg from n.args) this[arg.type](arg, n)
						n.infer = float
						return Post(n)
					}

					// we can call objects directly
					if(n.fn.infer && n.fn.infer.name == 'object'){
						new_context = n.fn.infer.ref
						context_name = n.fn.infer.ref_name
						name = 'call'
					}
					else{
						// 
						var compiler = 'compiler_' + name
						if(this[compiler]){
							return this[compiler](n, parent)
						}

						var type = find_type(name)

						// type infer the args
						for(var arg from n.args) this[arg.type](arg, n)

						// type constructor
						if(type){
							n.infer = type
							// lets do the args
							return Post(n)
						}
					}
				}
				else{
					// we are a function on another object
					new_context = n.fn.object.infer.ref
					context_name = n.fn.object.infer.ref_name
					name = n.fn.key.name
				}

				// type infer the args
				for(var arg from n.args) this[arg.type](arg, n)

				// lets check if we are calling a macro
				
				//console.log(n.args, name)

				// calls on other objects provide a new context
				// i know. i need to refactor this to be nicer. or learn to program
				var old_context = context
				if(new_context) context = new_context
				n.args.expanded = true
				var [macro, macro_generics] = find_macro(n, name, n.args)

				if(macro){
					// we are a macro
					if(macro.type == 'Function'){
						// lets type infer trace an actual macro call
						var old_scope = scope
						var old_return = return_type
						var old_module = this.module
						var old_generics = generics
						generics = macro_generics
						return_type = undefined
						var mparams = macro.params
						scope = Object.create(null)
						marks = Object.create(null)
						if(macro.module) this.module = macro.module
						for(var i, arg from n.args){
							if(!arg.infer) throw new Error('Cannot infer arg in macro '+name)
							if(arg.infer.name == 'object') throw new Error('Object arguments to function not implemented yet')
							var name = mparams[i].id.name
							scope[name] = arg.infer
							marks[name] = arg.mark
						}
						// lets set the arguments on the scope
						this[macro.type](macro, n)
						this.module = old_module
						generics = old_generics
						scope = old_scope
						n.infer = return_type
						// bubble up mark from function
						if(n.mark === undefined || n.mark < macro.mark) n.mark = macro.mark
						return_type = old_return
					}
					else if(macro.type == 'Call'){

						var old_args = macro_args
						old_generics = generics
						generics = macro_generics
						macro_args = Object.create(null)
						var margs = macro.args
						for(var i, arg from n.args){
							if(arg.infer.name == 'object') throw new Error('Object arguments to function not implemented yet')
							macro_args[margs[i].name] = arg
						}
						var astnode = macro.parent.value
						// type infer trace a macro!
						this[astnode.type](astnode, n)
						n.infer = astnode.infer
						macro_args = old_args
					}
					else throw new Error('Macro called but not a function '+name)
					// we have to figure out a return-type trace on our macro
					if(new_context) context = old_context
					return Post(n)
				}
				if(new_context) context = old_context
			}
			
			// otherwise it may be a type method, we need to trace it
			return AST.Walk::Call(n, parent)
		}

		// operator type inferencing
		Binary( n, parent ){
			n.parent = parent
			Pre(n)
			this[n.left.type](n.left, n)
			this[n.right.type](n.right, n)

			var left_i = n.left.infer.name
			var right_i = n.right.infer.name

			if(left_i == 'int' || left_i == 'float') n.infer = n.right.infer
			else if(right_i == 'int' || right_i == 'float') n.infer = n.left.infer
			else if(left_i == 'mat4'){
				if(right_i == 'vec2' || right_i == 'vec3' || right_i == 'vec4') n.infer = vec4
				else if(right_i == 'mat4') n.infer = mat4
			}
			else if(right_i == 'mat4'){
				if(left_i == 'vec2' || left_i == 'vec3' || left_i == 'vec4') n.infer = vec4
			}
			else if(left_i == 'vec3' && right_i == 'vec4'){
				n.infer = vec4
			}
			else if(left_i == 'vec4' && right_i == 'vec3'){
				n.infer = vec4
			}

			Post(n)
		}

		check_swizzle = AST.ToJS.check_swizzle
		find_define = AST.ToJS.find_define
		find_type = AST.ToJS.find_type
		find_macro = AST.ToJS.find_macro
		macro_match_args = AST.ToJS.macro_match_args
	}

	// generate the GLSL
	class GenGLSL extends AST.ToCode{
		term = ';'

		// otherwise if we are not 'pixel' we need to spit out varyings.
		expand( n, parent ){
			//log(n.type)
			if(n.mark == 1){ // we are a uniform dependent expression
				// okay
				if(!n.infer) throw new Error('Failed to infer type '+n.toDump())
				// okay so, we are a uniform. we splice in
				// a temp uniform, and we define it
				var type_name = n.infer.name
				var uni = {
					module: this.module
					name: (pixel?'pix_':'vtx_') + type_name + '_' + (uniform_id++)
					node: n
				}
				if(!(type_name in glsl_types)) this.types[type_name] = n.infer
				uniforms.push(uni)
				return uni.name
			}
			// output vertex varying
			if(pixel && n.mark == 2){
				// alright we need to output a vertex varying
				var type_name = n.infer.name
				var vary = {
					name: 'var_' + type_name + '_' + (varying_id++)
					node: n
				}
				varyings.push(vary)
				if(!(type_name in glsl_types)) this.types[type_name] = n.infer

				return vary.name
				//log('here', n.toDump())
			}
			// otherwise output self
			return AST.ToCode::expand(n, parent)
		}

		// Id resolver
		Id( n ){
			var name = n.name
			// if we are # bla lets resolve the color and inline.
			if(n.flag == 35){ // is a color
				vec3 col = ONE.color(name)
				return 'vec3(' + col.x + ',' + col.y + ',' + col.z + ')'
			}
			
			if(name in glsl_functions || name in glsl_variables){
				return name
			}
			
			// check macro args
			if(macro_args && name in macro_args){
				return '(' + macro_args[name] + ')'
			}

			if(iterators && name in iterators){
				return iterators[name]
			}

			if(scope && name in scope){
				return name
			}

			var prop = context[name]
			if(prop === undefined) throw new Error("cannot resolve " + name)
			
			// temporary variable generation
			if(prop._ast_){

				var node = prop
				var type = node.type
				var old_module = this.module
				if(type == 'Id' || type == 'Value' || 
					type == 'Key' || (type == 'Index' &&
						(!node.index || node.index.type == 'Value'))){
					this.module = prop.module
					var ret = expand(prop, n)
					this.module = old_module
					return ret
				}
				// use a tempvar
				var count = refcount[name]
				if(typeof count == 'object'){
					// we already have it defined
					tmpvars.splice(tmpvars.indexOf(count), 1)
					tmpvars.push(count)
					return count.name
				}
				else if(count>1){ // define it
					var tmp = {
						name:'tmp_' + n.infer.name + '_' + (uniform_id++),
						type:n.infer.name,
						value:expand(prop, n)
					}
					refcount[name] = tmp
					tmpvars.push(tmp)
					return tmp.name
				}
				this.module = prop.module
				var ret = expand(prop, n)
				this.module = old_module
				return ret
			}
			
			throw new Error('Dont know what to do with '+name)
			
			return ''
		}
		
		// resolve index
		Index( n ){
			// so we got a bla[]
			if(!n.index){
				if(n.object.type != 'Id') throw new Error('dont support property attributes')
				
				var name = n.object.name
				var obj = context[name]
				
				if(!(n.infer.name in glsl_types)){
					throw new Error('Dont support plain struct attributes('+n.infer.name+'), access the primitive properties')
				}
				if(!obj) throw new Error('Cannot find vertex attribute[] ' + name)
				
				var attr = attribs[name]
				if(attr && attr !== obj) throw new Error('Cannot redefine vertex attribute[] ' + name)

				attribs[name] = obj
				
				return name // return name
			}
			return AST.ToCode::Index(n)
		}
		
		// we have to resolve Id's
		Key( n ){
			if(n.const_length){
				return n.const_length
			}
			if(n.object.type == 'Index' && !n.object.index && !(n.object.infer.name in glsl_types)){
				// we have to create a sub attribute mapping
				var name = n.object.object.name
				var obj = context[name]
				if(!obj) throw new Error('Cannot find vertex attribute[] ' + name)

				var sub = sub_attribs[name] || (sub_attribs[name] = Object.create(null))
				
				sub[n.key.name] = obj

				name += '_' + n.key.name
				attribs[name] = {sub: obj.t.fields[n.key.name]}
				return name
			}
			if(n.object.type == 'Id'){
				var objname = n.object.name  
				if(objname in glsl_variables){
					return objname + '.' + n.key.name
				}
			}
			// lets only resolve the object, en just postfix the key
			return expand(n.object, n) + '.' + n.key.name
		}

		Unary( n, parent ){
			if(n.op.length != 1) throw new Error('Unary '+n.op+' not supported in shaders')
			return AST.ToCode::Unary( n. parent)
		}

		Binary( n ){
			var left_i = n.left.infer.name
			var right_i = n.right.infer.name
			var left_t = n.left.type
			var right_t = n.right.type
			var left = this.expand(n.left, n)
			var right = this.expand(n.right, n)

			// auto int to float cast
			if(left_i == 'int' && right_i != 'int'){
				if(left_t == 'Value') left = n.left.raw + '.'
				else left = 'float(' + left + ')'
			}
			else if(right_i == 'int' && left_i != 'int'){
				if(right_t == 'Value') right = n.right.raw + '.'
				else right = 'float(' + right + ')'
			}
			// auto vector upgrade
			else if(left_i == 'mat4'){
				if(right_i == 'vec2') right = 'vec4(' + right + ',0.,1.)'
				else if(right_i == 'vec3') right = 'vec4(' + right + ',1.)'
			}
			else if(right_i == 'mat4'){
				if(left_i == 'vec2') left = 'vec4(' + left + ',0.,1.)'
				else if(left_i == 'vec3') left = 'vec4(' + left + ',1.)'
			}
			// auto expand vec3 to vec4
			else if(left_i == 'vec3' && right_i == 'vec4'){
				left = 'vec4(' + left + ',1.)'
			}
			else if(left_i == 'vec4' && right_i == 'vec3'){
				right = 'vec4(' + right + ',1.)'
			}

			// paren detect
			if(left_t == 'Assign' || left_t == 'List' || left_t == 'Condition' || 
				(left_t == 'Binary' || left_t == 'Logic') && n.left.prio < n.prio) 
				left = '(' + left + ')'

			if(right_t == 'Assign' || right_t == 'List' || right_t == 'Condition' || 
				(right_t == 'Binary' || right_t == 'Logic') &&  n.right.prio < n.prio) 
				right = '(' + right + ')'
			
			if(n.op == '**'){
				return 'pow(' + left + ',' + right + ')'
			}

			return left + space + n.op + space + right
		}

		Var( n ){
			var ret = ''
			for(var v from n.defs){
				if(ret) ret +=  term + newline + depth
				ret += Def(v)
			}
			return ret
		}

		// typevar needs its struct definitions
		TypeVar( n ){
			var type_name = n.kind.infer.name
			if(!(type_name in glsl_types)) types[type_name] = n.kind.infer
			return type_name + ' ' + flat(n.defs, n)
		}

		ForTo = AST.ToJS.ForTo

		ForFrom( n ){
			// supporting the most simple for from over a known type size
			var type = n.right.infer
			var value_name 
			if(n.right.type != 'Id') throw new Error('For from right hand type not a basic identifier')
			var array_name = expand(n.right, n)
			if(n.left.type == 'TypeVar' || n.left.type == 'Var'){
				var value_id = n.left.defs[0]
				value_name = value_id.id.name
				if(type.name !== value_id.infer.name) throw new Error('For From left hand type not equal to right hand, use var')
				if(!(type.name in glsl_types)) types[type.name] = type
			}
			else if(n.left.type == 'Id'){
				value_name = n.left
				if(type.name !== n.left.infer.name) throw new Error('For From left hand type not equal to right hand, use var')
			}
			else throw new Error('Unusable left hand side in for from')
			var iter_name = alloc_var(n)

			if(!iterators) iterators = Object.create(null)
			iterators[value_name] = array_name + '[' + iter_name + ']'

			// lets define our loop variable
			var ret = 'for(int ' + iter_name +' = 0;' + iter_name + '<' + n.right.infer.dim + ';' + iter_name + '++)' + 
				expand(n.loop, n)

			return ret
		}

		Def( n ){
			var name = n.id.name
			scope[name] = n.infer

			var dim = ''
			if(n.infer.dim) dim = '[' + n.infer.dim + ']'

			if(n.parent.type == 'Var'){
				var type_name = n.infer.name
				if(!(type_name in glsl_types)) types[type_name] = n.infer
				if(!n.init){ // dont init
					return n.infer.name + ' ' + name + dim
				} 
				return n.infer.name + ' ' + name + dim +' = ' + expand(n.init, n)
			}
			else if(n.parent.type === 'TypeVar'){
				if(n.init) return name + dim + ' = ' + expand(n.init, n)
				return name + dim
			}
			else throw new Error('Unsupported Def encountered')
		}

		alloc_var( n ){
			while(n && n.var_alloc_id === undefined){
				n = n.parent
			}
			return name = 'tmp_' + (n.var_alloc_id++)
		}

		// Function!
		this.Function( n, name, argdef, ret_type ){
			n.var_alloc_id = 0

			// allright lets generate a function!
			var ret = ret_type.name + ' ' + name + '(' + argdef + ')'

			var old_depth = depth
			depth += indent

			var old_iterators = iterators
			iterators = undefined

			var body =  expand(n.body, n)
			
			ret += body
		
			depth = old_depth
			iterators = old_iterators

			return ret
		}

		var filter_shorten = {
			NEAREST:'N'
			LINEAR:'L'
			NEAREST_MIPMAP_NEAREST:'NN'
			LINEAR_MIPMAP_NEAREST:'LN'
			NEAREST_MIPMAP_LINEAR:'NL'
			LINEAR_MIPMAP_LINEAR:'LL'
			REPEAT:'R'
			CLAMP_TO_EDGE:'C'
			MIRRORED_REPEAT:'M'
		}

		// texture2D implementation
		compiler_texture2D( n ){
			// alright we have to concat the sampler flags
			var args = n.args
			var node = args[args.length - 1]
			var state = {}
			if(node.type == 'Object'){
				for(var tag from node.keys) state[tag.key.name] = tag.value.name
			}
			state.MIN_FILTER ?= 'LINEAR'
			state.MAG_FILTER ?= 'LINEAR'
			state.WRAP_S ?= 'REPEAT'
			state.WRAP_T ?= 'REPEAT'
			var hash = 
				filter_shorten[state.MIN_FILTER]+'_'+
				filter_shorten[state.MAG_FILTER]+'_'+
				filter_shorten[state.WRAP_S]+'_'+
				filter_shorten[state.WRAP_T]

			var source
			var image

			// fetch image object
			if(args[0].type == 'This'){
				source = context_name
				image = context
			}	
			else{
				source = args[0].name
				image = context[source]
			}

			// construct a sampler uid
			var sampler_id = 'sam_'+(image.proxy_uid || context_name)+ '_' + hash

			// store the sampler, with a
			var sam
			if(sam = samplers[sampler_id]){
				sam.target |= pixel?1:2
			}
			else{
				samplers[sampler_id] = {
					type:   'sampler2D'
					source: source
					image:  image
					ismip:  filter_shorten[state.MIN_FILTER].length == 2
					state:  state
					target: pixel?1:2
				}
			}

			var ret = 'texture2D('

			ret += sampler_id + ', '  +
				this.expand(args[1], n) 

			if(args.length > 2 && args[2].type != 'Object'){
				ret += ', ' + this.expand(args[2], n) 
			}
			ret += ')'

			return ret
		}

		// Do calls
		Call( n ){
			if(n.fn.type !== 'Id' && n.fn.type !== 'Key') 
				return AST.ToCode::Call(n)
			// check 
			var name 
			var new_context

			// its a call on another object
			if(n.fn.type == 'Key' || n.fn.infer && n.fn.infer.name == 'object'){
				if(n.fn.type == 'Key'){
					new_context = n.fn.object.infer.ref
					context_name = n.fn.object.name
					name = n.fn.key.name
				}
				else{
					new_context = n.fn.infer.ref
					context_name = n.fn.name
					name = 'call'
				}
			}
			else{
				name = n.fn.name

				var compiler_name = 'compiler_' + name
				if(this[compiler_name]){
					return this[compiler_name](n)
				}

				var type = find_type(name)
				// type constructor
				if(type){
					var ret = name + '(' 
					for(var i, arg from n.args){
						if(i) ret += ','
						ret += this[arg.type](arg, n)
					}
					ret += ')'
					return ret
				}
				// lets check our name against built in
				if(name in glsl_functions) return AST.ToCode::Call(n)
			}
			var old_context = context
			if(new_context) context = new_context

			n.args.expanded = true // skip argument expansion in find_macro
			var [macro, macro_generics] = find_macro(n, name, n.args)
			if(macro){
				if(macro.type == 'Function'){
					// generate GLSL function
					var params = macro.params
					var gen = 'macro_' + name
					var args = ''
					var argdef = ''
					var old_scope = scope
					var new_scope = Object.create(null)
					if(new_context) context = old_context

					for(var i, arg from n.args){
						if(i) args += ', ', argdef += ', '
						args += this[arg.type](arg, n)
						var type_name = arg.infer.name
						var param_name = params[i].id.name
						new_scope[param_name] = arg.infer
						argdef += type_name + ' ' + param_name
						gen += '_' + type_name
					}
					if(new_context) context = new_context

					scope = new_scope

					if(!type_methods[gen]){
						var old_depth = depth
						var old_args = macro_args
						var old_module = module
						var old_generics = generics

						generics = macro_generics
						macro_args = undefined
						depth = '\t\t\t'
						if(macro.module) this.module = macro.module

						type_methods[gen] = this.Function(macro, gen, argdef, n.infer)

						depth = old_depth
						generics = old_generics
						macro_args = old_args
						this.module = old_module
					}
					scope = old_scope

					if(new_context) context = old_context

					return gen + '(' + args + ')'
				}
				else if(macro.type == 'Call'){
					var old_args = macro_args
					var old_module = this.module
					var old_generics = generics

					generics = macro_generics
					macro_args = Object.create(null)
					var margs = macro.args
					if(new_context) context = old_context
					for(var i, arg from n.args){
						macro_args[margs[i].name] = this[arg.type](arg, n)
					}
					if(new_context) context = new_context
					var astnode = macro.parent.value
					this.module = astnode.module

					var ret = this[astnode.type](astnode, n)

					this.module = old_module
					generics = old_generics
					macro_args = old_args
					if(new_context) context = old_context

					return ret
				}
				throw new Error('Call failure')
			}
		}

		macro_match_args = AST.ToJS.macro_match_args
		find_macro = AST.ToJS.find_macro
		find_define = AST.ToJS.find_define
		find_type = AST.ToJS.find_type
	}

	// generate the uniform computation JS
	class GenUniformJS extends AST.ToJS{
		Id( n ){
			var name = n.name
			if(n.flag == 35){ // is a color
				return 'this.color("' + name + '")'
			}
			
			if(name in glsl_functions || name in glsl_variables){
				return name
			}
			
			var prop = context[name]
			
			if(prop === undefined || this.scope[name]) return this.resolve(n.name, n)
			
			if(prop && prop._ast_){
				var mod = this.module
				this.module = prop.module
				var ret = expand(prop, n)
				this.module = mod
				return ret
			}
			
			if(typeof prop == 'object'){
				//!TODO convert to signal
				deps[name] = proxy_props[name] = 1
				return 'this.' + name
			} 
			else if(typeof prop == 'number'){
				//!TODO convert to signal
				deps[name] = proxy_props[name] = 1
				return 'this.' + name
			}
			else throw new Error('Cant generate uniformJS for '+name)
		}
		// ok so if we depend on a subobject
		Key( n ){
			if(n.remote){
				var prop_name = n.object.name
				var dep_name = n.object.name + '.' + n.key.name
				deps[dep_name] = 1
				proxy_props[prop_name] = 1
				return 'this.'+dep_name
			}
			return AST.ToJS::Key(n)
		}
	}

	// type serializer
	function StructToGLSL( tabs, type, type_flatten ){
		var ret = '\n' + tabs + 'struct ' + type.name + '{\n'
		var fields = type.fields
		for(var name in fields){
			var field = fields[name]
			// lets check if we have the type
			var fname = field.name
			if(!(fname in glsl_types) && !(fname in type_flatten)){
				type_flatten[fname] = 1
				ret = StructToGLSL(tabs, field, type_flatten) + ret
			}
			ret += tabs + '\t' + fname + ' ' + name  
			if(field.dim) ret += '[' + field.dim + '];\n'
			else ret += ';\n'
		}  
		ret += tabs + '};'
		return ret
	}

	// uniform type expander
	function UniformTypeExpander( type, parts, base, glname, offset ){

		// lets check if our type is in the mappings
		var ismat
		var map = glsl_uniform_map[type.name] || (ismat = glsl_uniform_matrix[type.name])
		if(map){ // unroll it
			var viewsize =  AST.viewSize[type.view] 
			var off = ((type.off || 0) + offset) / viewsize

			parts.init += `\t\t\t\t\t\tshader.ul_${base} = gl.getUniformLocation(shader, "${glname}");\n`
			var call = 'gl.' + map 
			if(ismat){
				call += '(shader.ul_' + base + ',false'
				var last = off + ((type.dim || 1 ) * type.size) / viewsize 
				if(off) call += ',v.subarray(' + off + ',' + last +')'
				else call += ',v'
			}
			else{
				if(type.dim){
					call += 'v(shader.ul_' + base
					if(off){ // subarray
						var last = off + (type.dim * type.size) / viewsize 
						call += ',v.subarray(' + off + ',' + last + ')'
					}
					else{
						call += ',v'
					}
				}
				else{
					call += '(shader.ul_' + base
					if(type.slots == 1){
						if(off) call += ',v[' + off + ']'
						else call += ',v'
					}
					else for(var i = 0; i < type.slots; i++){
						call += ',v[' + (off + i) + ']'
					}
				}
			}
			call += ')'
			parts.setters += '\t\t\t\t\t' + call + '\n'
		}
		else {
			if(type.dim){
				for(var i = 0; i < type.dim; i++){
					for(var name in type.fields){
						UniformTypeExpander(type.fields[name], parts, base + '_'  + i + '_' + name, glname + '[' + i + '].' + name , offset + i * type.size)
					}
				}
			}
			else{
				// lets set all the fields
				for(var name in type.fields){
					var field = type.fields[name]
					UniformTypeExpander(field, parts, base + '_' + name, glname + '.' + name, offset)
				}
			}
		}
	}

	function DecodeBlend_factor( node, key ){
		if(node.type == 'Id') return glc.ONE
		if(node.type == 'Binary'){
			var factor = node.left
			if(node.right.name != key) throw new Error('Blend equation needs to have either pixel or frame on the right side of the *')
			if(factor.type == 'Binary'){ // its a one minus situation
				if(factor.op != '-' || factor.left.type != 'Value' || factor.left.value != 1) throw new Error('Invalid blending (only 1- supported)')
				var name = factor.right.name
				if(name == 'alpha') return glc.ONE_MINUS_SRC_ALPHA
				if(name == 'pixel') return glc.ONE_MINUS_SRC_COLOR
				if(name == 'frame') return glc.ONE_MINUS_DST_COLOR
				if(name == 'frame_alpha') return glc.ONE_MINUS_DST_ALPHA
				throw new Error('implement one minus mode')
			}
			if(factor.type != 'Id') throw new Error('Invalid blending (factor not an Id)')
			var name = factor.name
			if(name == 'alpha') return glc.SRC_ALPHA
			if(name == 'pixel') return glc.SRC_COLOR
			if(name == 'frame') return glc.DST_COLOR
			if(name == 'frame_alpha') return glc.DST_ALPHA
			// todo constant color and constant alpha
		}
		throw new Error('Invalid blending factor (node type invalid)')
	}

	function DecodeBlendEquation( eq ){
		var out = {}
		if(eq.type == 'Binary' && (eq.op == '+' || eq.op == '-')){ // its the main equation
			var left = eq.left
			var right = eq.right

			if(eq.op == '+') out.op = glc.FUNC_ADD
			else if(eq.op == '-') out.op = glc.FUNC_SUBTRACT

			if(left.type == 'Id' && left.name == 'pixel' || 
			   left.type == 'Binary' && left.right.name == 'pixel'){
				left = eq.right, right = eq.left
				if(eq.op == '-') out.op = glc.FUNC_REVERSE_SUBTRACT
			}
			// left should be frame, right should be pixel
			out.dst = DecodeBlend_factor(left, 'frame')
			out.src = DecodeBlend_factor(right, 'pixel')
		}
		else if(eq.type == 'Binary' && eq.op == '*'){ // its a single mul
			out.op = glc.FUNC_ADD
			// the right side needs to be either frame or pixel
			if(eq.right.name == 'frame'){
				out.src = glc.ZERO
				out.dst = DecodeBlend_factor(eq, 'frame')
			}
			else if(eq.right.name == 'pixel'){
				out.dst = glc.ZERO
				out.src = DecodeBlend_factor(eq, 'pixel')
			}
			else throw new Error('Blend equation needs to have either pixel or frame on the right side of the *')
		} 
		else if(eq.type == 'Id'){
			out.op = glc.FUNC_ADD
			if(eq.name == 'frame'){
				out.src = glc.ZERO
				out.dst = glc.ONE
			}
			else if(eq.name == 'pixel'){
				out.src = glc.ONE
				out.dst = glc.ZERO
			}
			else throw new Error('Blend equation invalid (not frame or pixel)')
		}
		else throw new Error('Blend equation invalid (main type) ' + eq.type + ' ' + eq.op)
		return out
	}

	var fake_module = {types:{},imports:[],defines:{}}

	class GenDrawJS extends AST.ToJS{
		
		context_resolve( name, n ){
			if(typeof context[name] !== 'undefined'){
				proxy_props[name] = 1
				n.infer = context[name].t || float
				return 'this.' + name
			}
		}

		_compile_drawSelf( n ){
		
			var uid = 'd' + ++this.uid

			var samplers = GenGLSL.samplers = {}

			// forward module and context
			GenGLSL.context = context
			var attribs = GenGLSL.attribs = Object.create(null)
			var sub_attribs = GenGLSL.sub_attribs = Object.create(null)

			DepTraceGLSL.context = context
			
			var pix = context.pixel
			// handle case where pixel is a plain value
			if(pix !== undefined && !pix._ast_) pix = {type:'Id', name:'pixel', module:fake_module}
			if(!pix) throw new Error('Unexpected pixel type')
			
			// deptrace the pixelshader
			GenGLSL.pixel = DepTraceGLSL.pixel = 1
			DepTraceGLSL.proxy_refs = proxy_refs
			GenGLSL.refcount = DepTraceGLSL.refcount = {}
			
			var alpha = context.alpha
			if(alpha){
				// alpha is a plain value
				if(!alpha._ast_) alpha = {type:'Id', name:'alpha', module:fake_module}
				DepTraceGLSL.module = alpha.module
				DepTraceGLSL[alpha.type](alpha)
			}

			DepTraceGLSL.module = pix.module
			DepTraceGLSL[pix.type](pix)

			//log(pix.bind.toDump())
			
			// codegen the pixelshader
			GenGLSL.uniform_id = 0
			GenGLSL.varying_id = 0
			GenGLSL.tmpvar_id = 0

			var pix_type_methods = GenGLSL.type_methods = {}
			var pix_uniforms = GenGLSL.uniforms = []
			var varyings = GenGLSL.varyings = []
			var pix_tmpvars = GenGLSL.tmpvars = []
			var pix_types = GenGLSL.types = {}
			var signal_deps = GenGLSL.sigdeps = []
			// generate pixel shader GLSL
			GenGLSL.module = pix.module
			var pix_expr = GenGLSL.expand(pix)

			var alpha_expr
			
			if(alpha){
				GenGLSL.module = alpha.module
				alpha_expr = GenGLSL.expand(alpha)
			}

			var always_opaque
			if(pix.infer.name == 'vec3'){
				if(alpha){
					pix_expr = 'vec4(' + pix_expr + ',' + alpha_expr + ')'
				}
				else{
					always_opaque = true
					pix_expr = 'vec4(' + pix_expr + ',' + '1.)'
				}
			} 
			else if(alpha){
				pix_expr = 'vec4((' + pix_expr +').rgb,' + alpha_expr + ')' 
			}

			// pull the vertex property from our context
			var vtx = context.vertex
			if(!vtx || !vtx._ast_) throw new Error('Unexpected vertex type')
			// dependency trace vertex shader
			GenGLSL.pixel = DepTraceGLSL.pixel = 0
			GenGLSL.refcount = DepTraceGLSL.refcount = {}
			GenGLSL.module = vtx.module
			GenGLSL.types = vtx_types

			DepTraceGLSL.module = vtx.module
			DepTraceGLSL[vtx.type](vtx)

			var vtx_type_methods = GenGLSL.type_methods = {}
			var vtx_uniforms = GenGLSL.uniforms = []
			var vtx_tmpvars = GenGLSL.tmpvars = []
			var vtx_types = GenGLSL.types = {}
			// generate vertex shader GLSL
			var vtx_expr = GenGLSL.expand(vtx)
			
			// patch up vertex position types just like color
			if(vtx.infer.name == 'vec3'){
				vtx_expr = 'vec4(' + vtx_expr + ',1.)'
			} 
			else if(vtx.infer.name == 'vec2'){
				vtx_expr = 'vec4(' + vtx_expr + ',0.,1.)'
			} 

			var vary_merged = ''
			var vary_decl = ''
			var vary_assign = ''
			var attr_decl = ''
			var pix_uni_decl = ''
			var vtx_uni_decl = ''
			var ret = ''
			
			// merge identical varyings
			var vary_merge = {}
			// generate varying assigns
			for(var vary from varyings){
				
				GenGLSL.uniforms = vtx_uniforms
				var code = GenGLSL.expand(vary.node)
				var typename = vary.node.infer.name
				var key = typename + code
				var merge = vary_merge[key]
				if(?merge){
					vary_merged += `
				#define ${vary.name} ${merge}
					`
					continue
				}
				vary_merge[key] = vary.name
				vary_decl +=`
				varying ${typename} ${vary.name};
				`
				vary_assign += `
					${vary.name} = ${code};
				`
			}
			
			// generate pixel uniform
			for(var uni from pix_uniforms){
				var type = uni.node.infer
				var dim = ''
				if(type.dim) dim = '[' + type.dim + ']'
				pix_uni_decl += `
				uniform ${type.name} ${uni.name}${dim};
				`
			}
			
			// generate vertex uniform
			for(var uni from vtx_uniforms){
				var type = uni.node.infer
				var dim = ''
				if(type.dim) dim = '[' + type.dim + ']'
				vtx_uni_decl += `
				uniform ${type.name} ${uni.name}${dim};
				`
			}
			
			// generate samplers
			for(var sam_name in samplers){
				var sam = samplers[sam_name]
				if(sam.target&1){ // pixelshader
					pix_uni_decl += `
				uniform ${sam.type} ${sam_name};
					`
				}
				if(sam.target&2){ // vertexshader
					vtx_uni_decl += `
				uniform ${sam.type} ${sam_name};
					`
				}
			}

			// generate attribute declarations
			for(var name in attribs){
				var attr = attribs[name]
				if(attr.sub){ // sub attribute
					attr_decl += `
				attribute ${attr.sub.name} ${name};
				`
				}
				else{
					attr_decl += `
				attribute ${attr.t.name} ${name};
				`
				}
			}

			var pix_tmpcode = ''
			
			// generate pixelshader tmpvars
			for(var i = pix_tmpvars.length - 1; i >=0; i--){
				var tmp = pix_tmpvars[i]
				pix_uni_decl += `
				${tmp.type} ${tmp.name};
				`
				pix_tmpcode += `
					${tmp.name} = ${tmp.value};
				`
			}

			var vtx_tmpcode = ''

			// generate vertexshader tmpvars
			for(var i = vtx_tmpvars.length - 1; i >=0; i--){
				var tmp = vtx_tmpvars[i]
				vtx_uni_decl += `
				${tmp.type} ${tmp.name}
				`
				vtx_tmpcode += `
					${tmp.name} = ${tmp.value};
				`
			}
			// generate pixelshader methods
			var pix_method_decl = ''
			for(var method in pix_type_methods){
				pix_method_decl += `
				${pix_type_methods[method]}
				`
			}

			// generate vertex shader methods
			var vtx_method_decl = ''
			for(var method in vtx_type_methods){
				vtx_method_decl += `
				${vtx_type_methods[method]}
				`
			}

			// generate pixelshader types
			var pix_type_decl = ''
			var pix_type_flat = Object.create(null)
			for(var type in pix_types){
				pix_type_decl += StructToGLSL('\t\t\t\t',pix_types[type], pix_type_flat)
			}

			// generate pixelshader types
			var vtx_type_decl = ''
			var vtx_type_flat = Object.create(null)
			for(var type in vtx_types){
				vtx_type_decl += StructToGLSL('\t\t\t\t',vtx_types[type], pix_type_flat)
			}

			// pixel shader
			var pix_shader = `
				precision highp float;${pix_type_decl}
				${pix_uni_decl}${vary_decl}${vary_merged}${pix_method_decl}
				void main(){
					${pix_tmpcode}
					gl_FragColor = ${pix_expr};
				}
			`

			// vertex shader
			var vtx_shader = `
				precision highp float;${vtx_type_decl}
				${vtx_uni_decl}${attr_decl}${vary_decl}${vtx_method_decl}
				void main(){
					${vtx_tmpcode}
					gl_Position = ${vtx_expr};
					${vary_assign}
				}
			`
			// the shader compiler code body
			ret += `
				var shader = this.${uid}_shader
				if(!shader){
					var pix_source = "${pix_shader.replace(/\n\t/g,'\\n\\\n\t\t\t')}"
					var vtx_source = "${vtx_shader.replace(/\n\t/g,'\\n\\\n\t\t\t')}"
					var cache_key = pix_source + vtx_source
					shader = gl._shadercache[cache_key]
					if(!shader){
						var pix_shader = gl.createShader(${glc.FRAGMENT_SHADER})
						
						gl.shaderSource(pix_shader, pix_source)
						gl.compileShader(pix_shader)
						if (!gl.getShaderParameter(pix_shader, ${glc.COMPILE_STATUS})){
							var err = gl.getShaderInfoLog(pix_shader)
							console.log(err.toString())
							throw new Error(err)
						}
						
						var vtx_shader = gl.createShader(${glc.VERTEX_SHADER})
						gl.shaderSource(vtx_shader, vtx_source)
						gl.compileShader(vtx_shader)
						if (!gl.getShaderParameter(vtx_shader, ${glc.COMPILE_STATUS})){
							var err = gl.getShaderInfoLog(vtx_shader)
							console.log(err.toString())
							throw new Error(err)
						}
						
						shader = gl.createProgram()
						gl.attachShader(shader, vtx_shader)
						gl.attachShader(shader, pix_shader)
						gl.linkProgram(shader)
						gl._shadercache[cache_key] = shader
			`

			// generate sampler uniform fetch
			for(var sam_name in samplers){
				ret += `
						shader.ul_${sam_name} = gl.getUniformLocation(shader, "${sam_name}")`
			}

			// uniform expander helpers
			GenUniformJS.store_tempid = 1000*this.uid + 1

			GenUniformJS.type_methods = type_methods
			var uniform_parts = {
				init:'',
				setters:''
			}

			// generate uniform setters
			for(var uni from pix_uniforms.concat(vtx_uniforms)){
				GenUniformJS.module = uni.module
				GenUniformJS.context = context
				GenUniformJS.proxy_props = proxy_props
				var deps = GenUniformJS.deps = Object.create(null)

				var js = GenUniformJS.expand(uni.node, n)
				
				var if_str = ''
				var as_str = ''
				for(var k in deps){
					var store = k.replace('.', '_')
					if(if_str)if_str += ' || ', as_str += ', '
					if_str += `shader.uv_${uni.name}_${store} !== this.${k}`
					as_str += `shader.uv_${uni.name}_${store} = this.${k}`
				}

				uniform_parts.setters += `
				if(${if_str}){
					${as_str}
					var v = ${js}\n`

				UniformTypeExpander(uni.node.infer, uniform_parts, uni.name, uni.name, 0)

				uniform_parts.setters += `
				}`
			}

			ret += '\n'+uniform_parts.init

			// fetch attribute locations
			for(var name in attribs)ret += `
						shader.al_${name} = gl.getAttribLocation(shader, "${name}")`
		
			// cache shader
			ret += 	`
					}
					this.${uid}_shader = shader`


			// create sub attribute buffers
			for(var name in sub_attribs){
				ret += `
					this.${uid}_vb_${name} = gl.createBuffer()`					
			}

			// create attribute buffers
			for(var name in attribs){
				if(attribs[name].sub) continue
				ret += `
					this.${uid}_vb_${name} = gl.createBuffer()`					
			}

			// done with the shader compile
			ret += `
				}
				gl.useProgram(shader)
			`
			var len = 0

			// sub attributes
			for(var name in sub_attribs){
				var sub_attr = sub_attribs[name]

				proxy_props[name] = 1

				var data = context[name]
				var newlen = data.buffer.byteLength / data.t.size
				if(len && newlen && len != newlen) throw new Error('Attribute arrays are not of the same length '+len+' and '+newlen)
				len = newlen

				ret += `
				gl.bindBuffer(${glc.ARRAY_BUFFER}, this.${uid}_vb_${name})
				var arr_buf = this.${name}.buffer
				if(!this.${uid}_vb_${name}.clean || !arr_buf.clean){
					gl.bufferData(${glc.ARRAY_BUFFER}, arr_buf, ${glc.STATIC_DRAW})
					arr_buf.clean = this.${uid}_vb_${name}.clean = true
				}
				`
				for(var sub in sub_attr){
					var type = sub_attr[sub].t
					var sub_type = type.fields[sub]
					var full_name = name + '_' + sub

					ret +=`
				var al = shader.al_${full_name}
				gl.enableVertexAttribArray(al)
				gl.vertexAttribPointer(al, ${sub_type.slots}, ${glc.FLOAT}, false, ${type.size}, ${sub_type.off})
				`
				}
			}

			// plain attributes
			for(var name in attribs){
				var attr = attribs[name]
				if(attr.sub) continue
				var type = attr.t

				var newlen
				newlen = attr.buffer.byteLength / attr.t.size
				if(len && newlen && len != newlen) throw new Error('Attribute arrays are not of the same length '+len+' and '+newlen)
				len = newlen

				proxy_props[name] = 1
				ret += `
				gl.bindBuffer(${glc.ARRAY_BUFFER}, this.${uid}_vb_${name})
				var arr_buf = this.${name}.buffer
				if(!this.${uid}_vb_${name}.clean || !arr_buf.clean){
					gl.bufferData(${glc.ARRAY_BUFFER}, arr_buf, ${glc.STATIC_DRAW})
					arr_buf.clean = this.${uid}_vb_${name}.clean = true
				}
				var al = shader.al_${name}
				gl.enableVertexAttribArray(al)
				gl.vertexAttribPointer(al, ${type.slots}, ${glc.FLOAT}, false, ${type.size}, 0)
				`
			}
			
			// samplers
			var tex_id = 0
			for(var sam_name in samplers){
				var sam = samplers[sam_name]
				var state = sam.state
				// alright we now have to set up the texture.
				ret += `
				if(this.${sam.source}.loaded){
					var tex
					if(!(tex = this.${sam.source}.tex || this.${sam.source}.${sam_name})){
						this.${sam.source}.${sam_name} = tex = gl.createTexture()
						gl.bindTexture(${glc.TEXTURE_2D}, tex)
						gl.texImage2D(${glc.TEXTURE_2D}, 0, ${glc.RGBA}, ${glc.RGBA}, ${glc.UNSIGNED_BYTE}, this.${sam.source}.img)
						gl.texParameteri(${glc.TEXTURE_2D}, ${glc.TEXTURE_MIN_FILTER}, ${glc[state.MIN_FILTER]})
						gl.texParameteri(${glc.TEXTURE_2D}, ${glc.TEXTURE_MAG_FILTER}, ${glc[state.MAG_FILTER]})
						gl.texParameteri(${glc.TEXTURE_2D}, ${glc.TEXTURE_WRAP_S}, ${glc[state.WRAP_S]})
						gl.texParameteri(${glc.TEXTURE_2D}, ${glc.TEXTURE_WRAP_T}, ${glc[state.WRAP_T]})
					`
					if(sam.ismip) ret += `
						gl.generateMipmap(${glc.TEXTURE_2D})
					`
					ret +=`
						gl.bindTexture(${glc.TEXTURE_2D}, null)
					}
					gl.activeTexture(${glc.TEXTURE0 + tex_id})
					gl.bindTexture(${glc.TEXTURE_2D}, tex)
					gl.uniform1i(shader.ul_${sam_name}, ${tex_id})
				}
				`
				tex_id ++ 
			}

			// alpha blending decoding
			var color_blend = DecodeBlendEquation(context.blend)
			if(context.blend_alpha){
				var alpha_blend = context.blend_alpha
				ret += `
				gl.enable(${glc.BLEND})
				gl.blendEquationSeparate(${color_blend.op},${alpha_blend.op})
				gl.blendFuncSeparate(${color_blend.src},${color_blend.dst},${alpha_blend.src},${alpha_blend.dst})
				`
			}
			else if(color_blend){
				if((always_opaque && color_blend.op == glc.FUNC_ADD && color_blend.dst == glc.ONE_MINUS_SRC_ALPHA && color_blend.src == glc.SRC_ALPHA) ||
					color_blend.op == glc.FUNC_ADD && color_blend.dst == glc.ZERO && color_blend.src == glc.ONE){
					ret += `
				gl.disable(${glc.BLEND})
				`
				}
				ret += `
				gl.enable(${glc.BLEND})
				gl.blendEquation(${color_blend.op})
				gl.blendFunc(${color_blend.src},${color_blend.dst})
				`
			}

			// fix the depth check
			var depth = context.depth
			if(depth){
				if(depth.type == 'Value' && (depth.value === true || depth.value === false)){
					if(depth.value === true) ret += `
				gl.disable(${glc.DEPTH_TEST})
					`
					else ret += `
				gl.enable(${glc.DEPTH_TEST})
				gl.depthFunc(${glc.NEVER})
					`
				} 
				else if(depth.type == 'Logic' && depth.left.name == 'pixel' && depth.right.name == 'frame'){
					ret +=`
				gl.enable(${glc.DEPTH_TEST})
				gl.depthFunc(${glsl_compare[depth.op]})
					`
				}
			}
			else throw new Error('Unsupported depth equation')

			// drawing function
			ret += `
				${uniform_parts.setters}
				gl.drawArrays(${glc.TRIANGLES}, 0, ${len})
			`
			// correctly indent the code
			ret = ret.replace(/\n\t\t\t\t/g, '\n' + this.indent)
			return ret
		}
	}
}

// framebuffer class
class Frame extends Node{
}

// lets first load up the image somehow
class Image extends Proxy{
	
	_sampler2D_ =  1
	
	size = vec2(0,0)

	_init(url){
		Proxy::_init()
		this._image_ = 1
		this.url = url
		proxy_props = {url:1}
	}

	init:(parent){
		// lets load up the Image
		img = new window.Image()
		img.onload()=>{
			loaded = true
		}
		img.src = url
	}

	call:(float x, float y){
		return texture2D(this, vec2(x, y), {
			MIN_FILTER:LINEAR
			MAG_FILTER:LINEAR
			WRAP_S:CLAMP_TO_EDGE
			WRAP_T:CLAMP_TO_EDGE
		})
	}

	call_:(vec2 p){
		return texture2D(this, p, {
			MIN_FILTER:LINEAR
			MAG_FILTER:LINEAR
			WRAP_S:CLAMP_TO_EDGE
			WRAP_T:CLAMP_TO_EDGE
		})
	}

	sample:(vec2 v){
		return texture2D(this, v, {
			MIN_FILTER:LINEAR
			MAG_FILTER:LINEAR
			WRAP_S:CLAMP_TO_EDGE
			WRAP_T:CLAMP_TO_EDGE
		})
	}
}

class View extends Node{

	fill = #black

	w := 0
	h := 0
	aspect := 0
	ratio := 1
	frame := 0

	draw:(){
		clearAll(fill)
	}

	init:(parent){
		child = []
		if(!parent) parent = document.body

		canvas = document.createElement("canvas")
		parent.appendChild(canvas)
		var _gl = gl = canvas.getContext('webgl',{
			alpha: false,
			depth: true,
			stencil: false,
			antialias: true,
			premultipliedAlpha: false,
			preserveDrawingBuffer: true
		})
		//canvas.webkitRequestFullscreen()
		window.onresize = =>{
			var pixelRatio = window.devicePixelRatio
			var w = parent.offsetWidth
			var h = parent.offsetHeight
			var sw = w * pixelRatio
			var sh = h * pixelRatio
			gl.width = canvas.width = sw
			gl.height = canvas.height = sh
			canvas.style.width = w + 'px'
			canvas.style.height = h + 'px'
			if(_gl)_gl.viewport(0, 0, sw, sh)
		}
		window.onresize()
		gl._shadercache = {}

		// lets request an init
		drawloop(time)=>{
			// call update
			if(!start) start = time
			sec = (time - start) / 1000

			draw(gl)
			for(var a from anim_hooks){
				a(sec)
			}
			for(var c from child){
				c.draw(gl)
			}
			// check if we are looping
			if(anim_hooks.length) window.requestAnimationFrame(drawloop)
		}

		changed(node){

		}

		anim_hooks = []

		anim_hook(cb){
			var idx = anim_hooks.push(cb) - 1
			if(!idx){
				window.requestAnimationFrame(drawloop)
			}
			return idx
		}

		anim_unhook(cb, idx){
			var idx = anim_hooks.indexOf(cb)
			if(idx != -1) anim_hooks.splice(idx, 1)
		}

		window.requestAnimationFrame(drawloop)
	}
}
