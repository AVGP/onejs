import math

class GLView{
	init( parent ){
		if(!parent) return
		
		pixelRatio = window.devicePixelRatio
		canvas = document.createElement("canvas")
		parent.appendChild(canvas)
		gl = canvas.getContext('webgl',{
			alpha: false,
			depth: true,
			stencil: false,
			antialias: false,
			premultipliedAlpha: false,
			preserveDrawingBuffer: true
		})
		
		var _gl = gl
		window.onresize = =>{
			var w = parent.offsetWidth
			var h = parent.offsetHeight
			canvas.style.width = w
			canvas.style.height = h
			canvas.width = w * pixelRatio
			canvas.height = h * pixelRatio
			_gl.viewport(0,0,w * pixelRatio, h * pixelRatio)
		}
		window.onresize()
	}
}

vec3Rect( x, y, w, h, z = 0 ){
	return vec3[6](
		x,y,z,   x+w,y,z,   x,y+h,z
		x+w,y,z, x+w,y+h,z, x,y+h,z
	)
}

vec4Rect( x, y, w, h, z = 0, ww = 1 ){
	return vec4[6](
		x,y,z,ww,   x+w,y,z,ww,   x,y+h,z,ww
		x+w,y,z,ww, x+w,y+h,z,ww, x,y+h,z,ww
	)
}
class GLNode{

	clearAll:( vec3 col ){
		gl.clearColor(col[0], col[1], col[2], 1.0)
		gl.colorMask(true, true, true, true)
		gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)
	}

	type: triangle

	enum glsl_variables{
		gl_PointCoord, gl_FrontFacing, gl_FragCoord, gl_Position
		gl_PointSize, gl_ClipDistance, gl_VertexID, gl_InstanceID
		gl_MaxVertexAttribs, gl_MaxVertexUniformVectors
		gl_MaxVaryingVectors, gl_MaxVertexTextureImageUnits
		gl_MaxCombinedTextureImageUnits, gl_MaxTextureImageUnits
		gl_MaxFragmentUniformVectors, gl_MaxDrawBuffers
	}

	enum glsl_types{
		half, float, double, short, long
		mat2, mat3, mat4
		vec2, vec3, vec4
		ivec2, ivec3, ivec4
		bvec2, bvec3, bvec4
		hvec2, hvec3, hvec4
		dvec2, dvec3, dvec4
		fvec2, fvec3, fvec4
		sampler2D
		samplerCube
	}
	
	enum glsl_functions{
		sizeof, radians, degrees
		sin, cos, tan
		asin, acos, atan
		pow, exp, log, exp2, log2
		sqrt, inversesqrt
		abs, sign, floor, ceil, fract
		mod, min, max, clamp
		mix, step, smoothstep
		length, distance
		dot, cross, normalize
		faceforward, reflect, refract
		matrixCompMult
		lessThan, lessThanEqual
		greaterThan, greaterThanEqual
		equal, notEqual
		any, all, not
		texture2DLod
		texture2DProjLod
		textureCubeLod
		texture2D
		texture2DProj
		textureCube
	}
	
	var glsl_uniform_map = {
		float:v -> 'uniform1f(' + v + ',false,v)'
		vec2: v -> 'uniform2fv(' + v + ',false,v)'
		vec3: v -> 'uniform3fv(' + v + ',false,v)'
		vec4: v -> 'uniform4fv(' + v + ',false,v)'
		mat4: v -> 'uniformMatrix4fv(' + v + ',false,v)'

	}
	
	class DepTraceGLSL extends AST.Walk{
		// causes dependency marks to travel up the tree
		// uniform has mark 1
		// attribute has mark 2
		// pixel has mark 3
		All( n, omark ){
			// lets propagate up our mark to our parent
			var parent = n.parent
			var nmark = omark || n.mark
			if(!nmark || !parent) return
			var pmark = parent.mark
			if(!pmark) parent.mark = nmark
			else if(pmark < nmark) parent.mark = nmark
			// lets keep it simple and copy our 'infer' up
			// any deviations from this are custom overloaded
			if(!parent.infer) parent.infer = n.infer
		}
		
		Do( n, parent ){
			n.parent = parent
			AST.Walk::Do(n, parent)
			// fuse mark properly
			if(n.arg.mark > n.call.mark) n.call.mark = n.arg.mark
		}
		
		Id( n, parent ){
			n.parent = parent
			var name = n.name
			if(n.flag == 35) return // is color
			if(name in glsl_functions || name in glsl_variables){
				if(name == 'gl_FragCoord') n.mark = 3
				return
			}
			// lets resolve name
			var prop = context[name]
			if(prop === undefined) throw new Error('Cannot resolve ' + name)
			
			if(typeof prop == 'object' && prop.bind){
				// what if we are a normal property with a value?..
				// we will need to 
				if(!prop.bind) throw new Error('invalid property ' + name)
				// we have a bind
				// check if its a value, or a fully static type constructor
				if(prop.bind.type == 'Value'){
					if(prop.bind.kind != 'num') throw new Error('invalid type in DepTraceGLSL ' + prop.bind.kind)
					n.mark = prop.bind.mark = 1
					n.infer = prop.bind.infer = module.types.float
					// lets replace the property with the actual value.
					prop.value = prop.bind.value
					// unbind the expression
					prop.bind = undefined
				}
				else {
					//!TODO check type constructor
					// otherwise we forward into the property
					this[prop.bind.type](prop.bind, n)
				}
			}
			else {
				//TODO turn properties into signals here!
				log(prop)
				if(typeof prop == 'object' && typeof prop.t == 'object'){
					n.mark = 1
					n.infer = prop.t
				} 
				else if(typeof prop == 'number'){
					n.mark = 1
					n.infer = modules.types.float
				}
				else throw new Error('Add other property types ' + name)
			}
			if(n.kind){
				// lets set our 'infer' to this type
				if(n.kind.name == 'pixel'){
					n.mark = 3	// mark us as pixel
				}
				else{
					// where do we get our typemap?
					n.infer = module.types[n.kind.name]
					if(!n.infer) throw new Error('cannot find type ' + n.kind.name)
				}
			}
			All(n)
		}
		
		Index( n, parent ){
			n.parent = parent
			if(!n.index){
				var nmark = n.mark = 2 // mark as attribute
				if(n.object.kind && n.object.kind.name == 'pixel')
					nmark = 3
				// what is our our type however?..
				var attrib = context[n.object.name]
				if(!attrib) throw new Error('cannot fetch attribute '+n.object.name)
				n.infer = attrib.t
				return All(n, nmark)
			}
			return AST.Walk::Index(n)
		}
		
		Key( n, parent ){
			n.parent = parent
			// we are a *.key
			// what we dont want to do is resolve the key.
			// we only want to walk the object.
			if(n.object.type == 'Id'){ 
				var objname = n.object.name
				
				if(objname in glsl_variables){
					if(objname == 'gl_FragCoord') n.mark = 3
					return All(n)
				}
			}
			// only try to walk/resolve the object
			this[n.object.type](n.object, n)
			// we have to have an inferred type on object now
			if(!n.infer) throw new Error('key access without type')
			
			var fields = n.infer.fields
			if(!fields) throw new Error('key access on type without fields')
			
			var type = fields[n.key.name]
			if(!type) throw new Error('type '+n.infer.name+' has no field '+n.key.name)
			
			n.infer = type
			
			return All(n)
		}
	}

	// generate the uniform computation JS
	class GenUniformJS extends AST.ToJS{
		// ok so, we have to expand into proper JS
		// depending on type oc.
		// what code do we generate?
		// what if a reference is a typed array type
		//
		// okay! we need to
		Id( n ){
			var name = n.name
			// if we are # bla lets resolve the color and inline.
			if(n.flag == 35){ // is a color
				return 'this.color("' + name + '")'
			}
			
			if(name in glsl_functions || name in glsl_variables){
				return name
			}
			
			var prop = context[name]
			if(prop === undefined) throw new Error("cannot resolve " + name)
			if(prop.bind){
				return expand(resolve.bind, n)
			} 
			
			if(typeof prop == 'object'){
				if(typeof prop.t !== 'object') return 'this.' + name +'.valueOf()'
				// we are accessing a struct
				return 'this.' + name
			} 
			else if(typeof prop == 'number'){
				// or an immediate value
				
			}
			else throw new Error('dont know what to do with '+name)
		}
	}

	// generate the GLSL
	class GenGLSL extends AST.ToCode{
		
		// otherwise if we are not 'pixel' we need to spit out varyings.
		expand( n, parent ){
			//log(n.type)
			if(!n.mark){ // precompile?..
			
			}
			if(n.mark == 1){ // we are a uniform dependent expression
				// okay
				if(!n.infer) throw new Error('Failed to infer type'+n.toDump())
				// okay so, we are a uniform. we splice in
				// a temp uniform, and we define it
				var uni = {
					name: 'uni' + (uniform_id++)
					node: n
				}
				uniforms.push(uni)
				return uni.name
				// and call GenUniformJS on us.
				// now what does that do in this case?
				// if GenUniform finds an id reference
			}
			// output vertex varying
			if(pixel && n.mark == 2){
				// ok so, what if we already have a varying
				// with the exact same 'node'
				
				
				// alright we need to output a vertex varying
				var vary = {
					name: 'var' + (varying_id++)
					node: n
				}
				varyings.push(vary)
				return vary.name
				//log('here', n.toDump())
			}
			// otherwise output self
			return AST.ToCode::expand(n, parent)
		}
		
		// Id resolver
		Id( n ){
			var name = n.name
			// if we are # bla lets resolve the color and inline.
			if(n.flag == 35){ // is a color
				vec4 col = context.color(name)
				return 'vec4(' + col.x + ',' + col.y + ',' + col.z + ',1.0)'
			}
			
			if(name in glsl_functions || name in glsl_variables){
				return name
			}
			
			var prop = context[name]
			if(prop === undefined) throw new Error("cannot resolve " + name)
			
			if(prop.bind) return expand(prop.bind, n)
			
			throw new Error('Dont know what to do with '+name)
			
			return ''
		}
		
		// resolve index
		Index( n ){
			// so we got a bla[]
			if(!n.index){
				if(n.object.type != 'Id') throw new Error('dont support property attributes')
				
				var name = n.object.name
				var obj = context[name]
				
				if(!obj) throw new Error('Cannot find vertex attribute[] ' + name)
				
				var attr = attribs[name]
				if(attr && attr !== obj) throw new Error('Cannot redefine vertex attribute[] '+name)
				
				attribs[name] = obj
				
				return name // return name
			}
			return AST.ToCode::Index(n)
		}
		
		// we have to resolve Id's
		Key( n ){
			if(n.object.type == 'Id'){
				var objname = n.object.name  
				if(objname in glsl_variables){
					return objname + '.' + n.key.name
				}
			}
			// lets only resolve the object, en just postfix the key
			return this.expand(n.object, n) + '.' + n.key.name
		}
		
		Do = AST.ToJS.Do
	}
	
	class GenDrawJS extends AST.ToJS{
		
		_compile_draw( n ){
			
			var uid = 'd' + this.uid++
			
			// setup module/context
			GenGLSL.module = module
			GenGLSL.context = context
			var attribs = GenGLSL.attribs = Object.create(null)
			
			DepTraceGLSL.context = context
			
			var pix = context.pixel
			if(!pix.bind) throw new Error('Unexpected pixel type')
			
			// call the dependency trace on our expression
			GenGLSL.pixel = DepTraceGLSL.pixel = 1
			DepTraceGLSL.module = module
			DepTraceGLSL[pix.bind.type](pix.bind)
			//log(pix.bind.toDump())
			
			// the run the code generator
			GenGLSL.uniform_id = 0
			GenGLSL.varying_id = 0
			
			var pix_uniforms = GenGLSL.uniforms = []
			var varyings = GenGLSL.varyings = []
			var pix_expr = GenGLSL.expand(pix.bind)
			
			// compile vertex shader
			var vtx = context.vertex
			if(!vtx.bind) throw new Error('Unexpected vertex type')
			
			// dependency trace vertex shader shader
			GenGLSL.pixel = DepTraceGLSL.pixel = 0
			DepTraceGLSL[vtx.bind.type](vtx.bind)
			
			// compile vertex shader
			var vtx_uniforms = GenGLSL.uniforms = []
			var vtx_expr = GenGLSL.expand(vtx.bind)
			
			var vary_merged = ''
			var vary_decl = ''
			var vary_assign = ''
			var attr_decl = ''
			var pix_uni_decl = ''
			var vtx_uni_decl = ''
			var ret = ''
			
			// merge identical varyings
			var vary_merge = {}
			// generate varying assigns
			for(var vary from varyings){
				
				GenGLSL.uniforms = vtx_uniforms
				var code = GenGLSL.expand(vary.node)
				var typename = vary.node.infer.name
				var key = typename + code
				var merge = vary_merge[key]
				if(?merge){
					vary_merged += `
				#define ${vary.name} ${merge}
					`
					continue
				}
				vary_merge[key] = vary.name
				vary_decl +=`
				varying ${typename} ${vary.name};
				`
				vary_assign += `
					${vary.name} = ${code};
				`
			}
			
			// generate pixel uniform
			for(var uni from pix_uniforms){
				pix_uni_decl += `
				uniform ${uni.node.infer.name} ${uni.name};
				`
			}
			
			// generate vertex uniform
			for(var uni from vtx_uniforms){
				vtx_uni_decl += `
				uniform ${uni.node.infer.name} ${uni.name};
				`
			}
			
			// generate attribute declarations
			for(var name in attribs){
				var attr = attribs[name]
				attr_decl += `
				attribute ${attr.t.name} ${name};
				`
			}
			// vertex shader
			var vtx_shader = `
				precision highp float;
				${vtx_uni_decl}${attr_decl}${vary_decl}
				void main(){
					gl_Position = ${vtx_expr};//vec4(${vtx_expr},1.0);
					${vary_assign}
				}
			`
			// pixel shader
			var pix_shader = `
				precision highp float;
				${pix_uni_decl}${vary_decl}${vary_merged}
				void main(){
					gl_FragColor = ${pix_expr};
				}
			`
			// we have to get a unique draw ID
			ret += `
				var shader = this.${uid}_shader
				if(!shader){
					var pix_shader = gl.createShader(${gl.FRAGMENT_SHADER})
					gl.shaderSource(pix_shader, "${pix_shader.replace(/\n\t/g,'\\n\\\n\t\t\t')}")
					gl.compileShader(pix_shader)
					if (!gl.getShaderParameter(pix_shader, ${gl.COMPILE_STATUS})){
						var err = gl.getShaderInfoLog(pix_shader)
						console.log(err.toString())
						throw new Error(err)
					}
					
					var vtx_shader = gl.createShader(${gl.VERTEX_SHADER})
					gl.shaderSource(vtx_shader, "${vtx_shader.replace(/\n\t/g,'\\n\\\n\t\t\t')}")
					gl.compileShader(vtx_shader)
					if (!gl.getShaderParameter(vtx_shader, ${gl.COMPILE_STATUS})){
						var err = gl.getShaderInfoLog(pix_shader)
						console.log(err.toString())
						throw new Error(err)
					}

					shader = gl.createProgram()
					gl.attachShader(shader, vtx_shader)
					gl.attachShader(shader, pix_shader)
					gl.linkProgram(shader)
					
					this.${uid}_shader = shader
			`
			
			for(var uni from pix_uniforms) ret += `
					this.${uid}_ul_${uni.name} = gl.getUniformLocation(shader, "${uni.name}");`
				
			for(var uni from vtx_uniforms) ret += `
					this.${uid}_ul_${uni.name} = gl.getUniformLocation(shader, "${uni.name}");`
			
			for(var name in attribs)ret += `
					this.${uid}_vb_${name} = gl.createBuffer()
					this.${uid}_al_${name} = gl.getAttribLocation(shader, "${name}");`
					
			ret += `
				}
				gl.useProgram(shader)
			`
			var len = 0
			for(var name in attribs){
				var attr = attribs[name]
				
				var abname = `${uid}_ab_${name}`
				len = attr.buffer.byteLength / attr.t.size
				context[abname] = attr.buffer
				
				ret += `
				gl.bindBuffer(${gl.ARRAY_BUFFER}, this.${uid}_vb_${name})
				var arr_buf = this.${abname}
				if(!arr_buf.clean){
					gl.bufferData(${gl.ARRAY_BUFFER}, arr_buf, ${gl.STATIC_DRAW})
					arr_buf.clean = true
				}
				var al = this.${uid}_al_${name}
				gl.enableVertexAttribArray(al)
				gl.vertexAttribPointer(al, ${attr.t.slots}, ${gl.FLOAT}, false, ${attr.t.size}, 0)
				`
			}
			
			// generate uniform setting
			for(var uni from pix_uniforms.concat(vtx_uniforms)){
				
				GenUniformJS.module = module
				GenUniformJS.context = context
				var js = GenUniformJS.expand(uni.node)
				
				var map = glsl_uniform_map[uni.node.infer.name]
				if(!map) throw new Error('unsupported uniform type ' + uni.node.infer.name)
				ret +=`
				var v = ${js}
				if(this.${uid}_uv_${uni.name} !== v){
					this.${uid}_uv_${uni.name} = v
					gl.${map(`this.${uid}_ul_${uni.name}`)}
				}
				`
			}
			
			// drawing function
			ret += `
				gl.drawArrays(gl.TRIANGLES, 0, ${len})
			`
			// correctly indent the code
			ret = ret.replace(/\n\t\t\t\t/g, '\n'+this.indent)
			return ret
		}
	}

	init(){
		// we have to compile the draw signal
		// alright lets stringify draw
		// so lets stringify it.
		var js = GenDrawJS
		var ast = draw.bind
		// make a fresh scope and signals store
		js.new_state()
		// plug the module of the ast node
		js.module = ast.module
		js.context = this
		js.gl = owner.gl // use the gl context to inline gl constants
		js.uid = 0
		if(ast.type != 'Function') throw new Error('GL Draw not a function')
		
		var flags = js.pull_flags(ast)
		var code = js.Function(ast, undefined, ['gl'])
		if(flags.indexOf('js') != -1) out(code)
		
		// lets eval it in our current space
		log(code)
		
		_draw = Function('module','return ' + code)(js.module)
		
		// just run it immediately, once.
		_draw(owner.gl)
	}
}
