import math
import gl
import glscene

class Codeview extends Text{

	// second level markers
		_Delim:0.
			_Paren:1.
				_ParenL:1.
				_ParenR:2.
			_Brace:2.
				_BraceL:1.
				_BraceR:2.
			_Bracket:3.
				_BracketL:1.
				_BracketR:2.

			_Comma:6.
			_Colon:9.
			_DColon:10.
			_Dot:11.
			_SemiColon:12.

			_Operator:13.
				_Plus:1.
				_Min:2.
				_Div:3.
				_Mul:4.
				_Pow:5.
				_Shl:6
				_Shr:7
				_EQ:8.
				_NEQ:9.
				_GT:10.
				_LT:11.
				_GTE:12.
				_LTE:13.
				_Plusplus:14.
				_Minmin:15.
				_Assign:16.
				_PlusAssign:17.
				_MinAssign:18.
				_MulAssign:19.
				_DivAssign:20.
				_ShlAssign:21.
				_ShrAssign:22.
				_TerniaryQ:23.
				_TerniaryC:24.
				_Signal:25.
		_String:2.
		_Number:3.
		_Tab:4.
		_Keyword:6.
		_Id:10.
		_Color:7.
		// Keywordy things

	// Base node markers
	_Id:10.
	_Value:11.
	_This:12.
	_Array:13.
	_Object:14.
	_Index:15.
	_Key:16.
	_ThisCall: 17.

	_Block:18.
	_List: 19.
	_Comprehension:20.
	_Template: 21.
	_Break:22.
	_Continue:23.
	_Label:24.

	_If:25.
	_Switch:26.
	_Case:27.

	_Throw:28.
	_Try:29.

	_While:30.
	_DoWhile:31.
	_For:32.
	_ForIn:33.
	_ForOf:34.
	_ForFrom:35.
	_ForTo:36.

	_Var:37.
	_TypeVar:38.
	_Struct:39.
	_Define:40.
	_Enum:41.

	_Def:42.

	_Function:43.
	_Return:44.
	_Yield:45.
	_Await:46.

	_Unary:47.
	_Binary:48.
	_Logic:49.
	_Assign:50.
	_Update:51.
	_Condition:52.

	_New:53.
	_Call:54.
	_Nest:55.

	_Class:56.
	_Signal:57.
	_Quote:58.
	_AssignQuote:59.
	_Rest:60.
	_Then:61.
		

	// Helper functions

	DColon(type){
		mark('::', type, _Delim, _DColon)
	}

	Dot(type){
		mark('.', type, _Delim, _Dot)
	}

	Colon(type){
		mark(':', type, _Delim, _Colon)
	}

	SemiColon(type){
		mark(':', type, _Delim, _SemiColon)
	}

	Comma(type){
		mark(',', type, _Delim, _Comma)
	}

	ParenL(type){
		mark('(', type, _Delim, _Paren, _ParenL)
	}

	ParenR(type){
		mark(')', type, _Delim, _Paren, _ParenL)
	}
	BraceL(type){
		mark('{', type, _Delim, _Brace, _BraceL)
	}

	BraceR(type){
		mark('}', type, _Delim, _Brace, _BraceR)
	}

	BracketL(type){
		mark('[', type, _Delim, _Bracket, _BracketL)
	}

	BracketR(type){
		mark(']', base, _Delim, _Bracket, _BracketR )
	}

	Operator(op, type){
		var col
		if(op == '++') col = _Plusplus
		if(op == '--') col = _Minmin
		if(op == '+') col = _Plus
		if(op == '-') col = _Min
		if(op == '/') col = _Div
		if(op == '*') col = _Mul
		if(op == '**') col = _Pow
		if(op == '==') col = _EQ
		if(op == '!=') col = _NEQ
		if(op == '>') col = _GT
		if(op == '<') col = _LT
		if(op == '=>') col = _GTE
		if(op == '<=') col = _LTE
		if(op == '<<') col = _Shl
		if(op == '>>') col = _Shr
		if(op == '=') col = _Assign
		if(op == ':=') col = _Signal
		if(op == '+=') col = _PlusAssign
		if(op == '-=') col = _MinAssign
		if(op == '/=') col = _DivAssign
		if(op == '*=') col = _MulAssign
		if(op == '<<=') col = _ShlAssign
		if(op == '>>=') col = _ShrAssign
		if(op == '?') col = _TerniaryQ
		if(op == ':') col = _TerniaryC

		mark(op, type, _Delim, _Operator, col)
	}

	Keyword(value, type){
		mark(value, type, _Keyword)
	}

	// AST Expander

	expand(n){
		if(n)this[n.type](n)
	}

	Program(n){}

	Empty(n){}


	Id(n){//{ name:0, flag:0, typing:1 },
		if(n.flag){
			mark('#'+n.name, _Id, _Color)
		}
		else
			mark(n.name, _Id, _Id)
	}

	Value(n){//: { value:0, raw:0, kind:0, multi:0 },
		if(n.kind == 'num')
			mark(n.raw, _Value, _Number)
		else if(n.kind == 'string')
			mark(n.raw, _Value, _String)
		else
			mark(n.raw, _Value)
	}
	
	This(n){//: { },
		mark('this', _This, _Keyword)
	}

	Array(n){//: { elems:2 },
		BracketL(_Array)
		for(var elem from n.elems){
			expand(elem)
			Comma(_Array)
		}
		BracketR(_Array)
	}
	Object(n){//: { keys:3 },
		BraceL(_Object)
		for(var prop from n.keys){
			expand(prop.key)
			Colon(_Object)
			expand(prop.value)
		}
		BraceR(_Object)
	}
	Index(n){//: { object:1, index:1 },
		expand(n.object)
		BraceL(_Index)
		expand(n.index)
		BraceR(_Index)
	}
	Key(n){//: { object:1, key:1, exist:0 },
		expand(n.object)
		Dot(_Key)
		expand(n.key)
	}
	ThisCall(n){//: { object:1, key:1 },
		expand(n.object)
		DColon(_ThisCall)
		expand(n.key)
	}

	Block(n){//:{ steps:2 },
		BraceL(_Block)
		var old_indent = indent
		indent++
		newline()
		tab(indent)
		for(var len, i, step from n.steps){
			expand(step)
			newline()
			if(i == len - 1) tab(old_indent)
			else tab(indent)
		}
		indent = old_indent
		BraceR(_Block)
	}
	List(n){//: { items:2 },
		for(var i, item from n.items){
			if(i) Comma(_List)
			expand(item)
		}
	}

	Comprehension(n){//:{ for:1, expr:1 },
	}
	Template(n){//: { chain:2 },
	}

	Break(n){//: { label:1 },
		Keyword('break', _Break)
	}
	Continue(n){//: { label:1 },
		Keyword('continue', _Continue)
	}
	Label(n){//: { label:1, body:1 },
		expand(n.label)
		expand(n.body)
	}
	If(n){//: { test:1, then:1, else:1, postfix:0, compr:0 },
		Keyword('if', _If)
		ParenL(_If)
		expand(n.test)
		ParenR(_If)
		expand(n.then)
		if(n.else){
			newline()
			tab(indent)
			Keyword('else', _If)
			space()
			expand(n.else)
		}
	}
	Switch(n){//: { on:1, cases:2 },
		Keyword('switch', _Switch)
		ParenL(_Switch)
		expand(n.on)
		ParenR(_Switch)
		BraceL(_Switch)
		for(var c from n.cases){
			expand(c)
		}
		BraceR(_Switch)
	}
	Case(n){//: { test:1, then:2 },
		Keyword('case', _Case)
		expand(n.test)
		Colon(_Case)
		expand(n.then)
	}
	Throw(n){//: { arg:1 },
		Keyword('throw', _Throw)
		expand(n.arg)
	}
	Try(n){//: { try:1, arg:1, catch:1, finally:1 },
		Keyword('try', _Try)
		expand(n.try)
		Keyword('catch', _Try)
		ParenL(_Try)
		expand(n.arg)
		ParenR(_Try)
		expand(n.catch)
		if(n.finally){
			Keyword('finally', _Try)
			expand(n.finally)
		}
	}
	While(n){//: { test:1, loop:1 },
		Keyword('while', _While)
		ParenL(_While)
		expand(n.test)
		ParenR(_While)
		expand(n.loop)
	}
	DoWhile(n){//: { loop:1, test:1 },
		Keyword('do', _Do)
		expand(n.loop)
		Keyword('while', _Do)
		ParenL(_Do)
		expand(n.test)
		ParenR(_Do)
	}
	For(n){//: { init:1, test:1, update:1, loop:1, compr:0 },
		Keyword('for', _For)
		expand(n.init)
		SemiColon(_For)
		space()
		expand(n.test)
		SemiColon(_For)
		space()
		expand(n.update)
		expand(n.loop)
	}
	ForIn(n){//: { left:1, right:1, loop:1, compr:0 },
		Keyword('for', _For)
		ParenL(_For)
		expand(n.left)
		space()
		Keyword('in', _For)
		space()
		expand(n.right)
		ParenR(_For)
		expand(n.loop)
	}
	ForOf(n){//: { left:1, right:1, loop:1, compr:0 },
		Keyword('for', _For)
		ParenL(_For)
		expand(n.left)
		space()
		Keyword('of', _For)
		space()
		expand(n.right)
		ParenR(_For)
		expand(n.loop)
	}
	ForFrom(n){//: { right:1, left:1, loop:1, compr:0 }, // right comes first for type inference
		Keyword('for', _For)
		ParenL(_For)
		expand(n.left)
		space()
		Keyword('from', _For)
		space()
		expand(n.right)
		ParenR(_For)
		expand(n.loop)
	}
	ForTo(n){//: { left:1, right:1, loop:1, in:1, compr:0 },
		Keyword('for', _For)
		ParenL(_For)
		expand(n.left)
		space()
		Keyword('to', _For)
		space()
		expand(n.right)
		ParenR(_For)
		expand(n.loop)
	}
	Var(n){//: { defs:2, const:0 },
		Keyword('var', _Var)
		space()
		for(var i, def from n.defs){
			if(i) Comma(_Var), space()
			expand(def)
		}
	}
	TypeVar(n){//: { typing:1, defs:2, dim:1 },
		Keyword(n.typing.name, _TypeVar)
		space()
		for(var i, def from n.defs){
			if(i) Comma(_Var), space()
			expand(def)
		}
	}
	Struct(n){//: { id:1, struct:1, base:1, defs:2, dim:1 },
		Keyword('struct', _Struct)
		space()
		expand(n.id)
		expand(n.struct)
	}
	Define(n){//: { id:1, value:1 },
		Keyword('define', _Define)
		space()
		expand(n.id)
		space()
		expand(n.value)
	}
	Enum(n){//: { id:1, enums:2 }, 
		Keyword('enum', _Enum)
		space()
		expand(n.id)
		BraceL(_Enum)
		newline()
		for(var e from n.enums){
			expand(e)
		}
		BraceR(_Enum)
	}

	Def(n){//: { id:1, init:1, dim:1 },
		expand(n.id)
		if(n.init){
			space()
			Operator('=', _Def)
			space()
			expand(n.init)
		}
	}

	Function(n){//: { id:1, name:1, params:2, rest:1, body:1, arrow:0, gen:0, def:0 },
		if(n.arrow){

		}
		if(n.name) expand(n.name)
		//else Keyword('function', _Function)
		if(n.id) space(), expand(n.id)
		ParenL(_Function)
		for(var i, param from n.params){
			if(i) Comma(_Function), space()
			expand(param)
		}
		ParenR(_Function)
		expand(n.body)
	}
	Return(n){//: { arg:1 },
		Keyword('return', _Return)
		if(n.arg) space(), expand(n.arg)
	}
	Yield(n){//: { arg:1 },
		Keyword('yield', _Yield)
		if(n.arg) space(), expand(n.arg)
	}
	Await(n){//: { arg:1 },
		Keyword('await', _Await)
		if(n.arg) space(), expand(n.arg)
	}
	Unary(n){//: { op:0, prefix:0, arg:1 },
		if(n.prefix){
			if(n.op.length!=1)
				Keyword(n.op, _Unary), space()
			else
				Operator(n.op, _Unary)
			expand(n.arg)
		}
		else{
			expand(n.arg)
			Operator(n.op, _Unary)
		}
	}
	Binary(n){//: { op:0, prio:0, left:1, right:1 },
		var paren_l = AST.needsParens(n, n.left)
		var paren_r = AST.needsParens(n, n.right)
		if(paren_l) ParenL(_Binary)
		expand(n.left)
		if(paren_l) ParenR(_Binary)
		space()
		Operator(n.op, _Binary)
		space()
		if(paren_r) ParenL(_Binary)
		expand(n.right)
		if(paren_r) ParenR(_Binary)
	}
	Logic(n){//: { op:0, prio:0, left:1, right:1 },
		var paren_l = AST.needsParens(n, n.left)
		var paren_r = AST.needsParens(n, n.right)
		if(paren_l) ParenL(_Logic)
		expand(n.left)
		if(paren_l) ParenR(_Logic)
		space()
		Operator(n.op, _Logic)
		space()
		if(paren_r) ParenL(_Logic)
		expand(n.right)
		if(paren_r) ParenR(_Logic)
	}
	Assign(n){//: { op:0, prio:0, left:1, right:1 },
		expand(n.left)
		space()
		Operator(n.op, _Assign)
		space()
		expand(n.right)
	}
	Update(n){//: { op:0, prio:0, arg:1, prefix:0 },
		if(prefix)
			Operator(n.op, _Update), expand(n.arg)
		else
			expand(n.arg), Operator(n.op, _Update)
	}
	Condition(n){//: { test:1, then:1, else:1 },
		expand(n.test)
		Operator('?', _Condition)
		expand(n.then)
		Operator(':', _Condition)
		expand(n.else)
	}
	New(n){//: { fn:1, args:2 },
		Keyword('new', _New)
		space()
		expand(n.fn)
		ParenL(_New)
		for(var i, args from n.args){
			if(i) Comma(_New), space()
			expand(args)
		}
		ParenR(_New)
	}

	Call(n){//: { fn:1, args:2 },
		expand(n.fn)
		ParenL(_Call)
		for(var i, args from n.args){
			if(i) Comma(_Call), space()
			expand(args)
		}
		ParenR(_Call)
	}

	Nest(n){//: { fn:1, body:1, arrow:0 },
		expand(n.fn)
		expand(n.body)
	}
	Class(n){//: { id:1, base:1, body:1 },
		Keyword('class', _Class)
		space()
		expand(n.id)
		if(n.base){
			space()
			Keyword('extends', _Class)
			space()
			expand(n.base)
		}
		expand(n.body)
	}
	Signal(n){//: { left:1, right:1 },
		expand(n.left)
		Operator(':=', _Signal)
		expand(n.right)
	}
	Quote(n){//: { quote:1 },
		Operator(':', _Quote)
		expand(n.quote)
	}
	AssignQuote(n){//: { left:1, quote:1 },
		expand(n.left)
		Operator(':', _AssignQuote)
		expand(n.quote)
	}
	Rest(n){//: { id:1, dots:0 },
		Operator('...', _Rest)
		expand(n.id)
	}
	Then(n){//: { name:1, do:1 },
	}
	Debugger(n){//: { },
	}
	With(n){//: { object:1, body:1 }
	}

	get ast(v){
		return __ast
	}
	set ast(v){
		__ast = v
		// ok lets turn this AST into an actual codeview.
		if(is_initialized){
			alloc(1000, true)
			indent = 0
			expand(v)
			update()
		}
	}

	constructor(){
		Text::constructor()
		ast = __ast
	}
}