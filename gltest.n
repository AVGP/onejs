import math
import webgl

class Rect extends Node{

	viewmtx: mat4.perspective(70deg, 1, -1, 1)
	objmtx: mat4.RT(30deg,  1deg*param1 + Time.sec,0,0,0,3)

	mesh = webgl.vec2Rect(-1,-1,2,2,0)
	vertex: mesh[] * (objmtx * viewmtx)

	// signal ready!
	param1 = 1

	p:pixel mesh[]

	bg = Image.new('texture1.jpg')
	bgcolor:#orange
	pixel:
		bg.blit(0.5 * p + 0.5) ** (
		(mix(bgcolor, #black) do 
			abs(sin(param1 * 1. * atan(p.x, p.y))))
		+
		mix(#green, #purple) do
			sin(sin(param1 + Time.sec) * param1 * p.x * p.y)
		)
	alpha: 1-length(p)**8.

	blend: alpha * pixel + (1-alpha) * frame
	depth: pixel < frame
/*
	// we have to make the render nodes here
	boxBlur = Rect{
		src = Image // give it a slot to compile
		depth: true
		pixel: src.sample(here) + 
			src.sample(there)
	}

	// something else	
	frameFill = Rect{
		src = Image
		pixel: src.sample(bla)
	}

	// what if we want to readpixel?... run it in draw:()?
	draw:(){
		// draw something into a framebuffer
		var buf1 = gl.lock() // lock a framebuffer 
		// push the render target
		gl.push(buf1)

		// you can use .call interface and parameterise them
		boxBlur.draw{
			src = buf1
		}

		gl.push(buf1)

		// draw children
		for(var c from child) c.draw()

		// create another buffer

		// vertical pass
		drawSelf{
			pixel:...
		}

		// horizontal pass
		drawSelf{
			pixel:
		}

		// draw resulting blur


		drawSelf()
		
		gl.pop()

		frameFill.draw()

		for(var c from child) c.draw()
	}

	output.readPixels(0,0) do(buf){

	}
	*/

}

// define a procedural texture?
var ref = View{
	fill = #aero
	Rect{ param1 = 10 }
}
