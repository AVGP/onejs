// Copyright (C) 2014 OneJS
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

import math
import text
import text_marked

// chunked text behaves like text
class ChunkedTextLayerImpl{
	// use layer matrices

	dontProxy('default_alloc', 'chunk_lines',
		'text_initialized','chunk_list','line_height',
		'cache_chunk','last_chunk','add_y','char_off')
	//dump = 1
	// load up the renderer
	load(MarkedTextLayerImpl)

	vertex: (mesh[].xy+vec2(text_x, text_y)) * (m_world * device.m_camera)

	// this thing holds the data, but not the rendering
	class Chunk extends WorkerProxy{
		load(MarkedTextLayerImpl)
		y = 0
		constructor(parent){
			this.parent = parent
			glyphyFromParent(parent)
			if(!parent.chunk_list)parent.chunk_list = []
			parent.chunk_list.push(this)
		}
		$constructor:(){
			if(!parent.chunk_list)parent.chunk_list = []
			parent.chunk_list.push(this)
		}
		$flagDirty:(){
			parent.redraw()
		}
	}
	// alright we have a Chunk which holds data
	// and a data API but isnt actually a rendernode
	// so how do we draw those things
	drawSelf:(sec){
		// draw markers
		for(var chunk from chunk_list){
			markers = chunk.markers
			text_y = chunk.y
			this{
				pixel:marker_paint()
				vertex:marker_vertex
			}
		}
		// lets draw our text
		for(var chunk from chunk_list){
			mesh = chunk.mesh
			tags = chunk.tags
		 	text_y = chunk.y
			this{}
		}
	}

	default_alloc = 5000
	chunk_lines = 100

	constructor(){
		MarkedTextLayerImpl::constructor()
		// create a new last_chunk to start growing
		last_chunk = this.Chunk.new(this)
		last_chunk.chunk_id = 0
		last_chunk.allocText(default_alloc)
		last_chunk.accum_off = 0
		char_off = 0
		add_y = 0
		//last_chunk.style = style
	}

	offsetFromPos(x, y){
		// scan the chunks by y pos
		if(!cache_chunk) cache_chunk = last_chunk
		// we have to correct for y being at the font baseline.
		while(cache_chunk && y < cache_chunk.baseToTop(cache_chunk.y)){
			cache_chunk = chunk_list[cache_chunk.chunk_id -1]
		}
		while(cache_chunk && y >= cache_chunk.baseToTop(cache_chunk.y) + cache_chunk.add_y){
			cache_chunk = chunk_list[cache_chunk.chunk_id + 1]
		}
		if(!cache_chunk) cache_chunk = last_chunk
		// lets find the closest character
		return cache_chunk.offsetFromPos(x, y - cache_chunk.y) + cache_chunk.accum_off
	}

	cursorRect(off){
		var chunk = findChunk(off)
		var rect = chunk.cursorRect(off - chunk.accum_off)		
		rect.y += chunk.y
		return rect
	}

	charBounds(off){
		var chunk = findChunk(off)
		var b = chunk.charBounds(off - chunk.accum_off)
		// we need to find the actual baseline for this 

		b.y += chunk.y
		return b
	}

	// we expose the Text api onto subchunks
	charTag(off){
		// we have to find the right character tag
		var chunk = findChunk(off)
		return chunk.charTag_z(off - chunk.accum_off)
	}
	
	findChunk(off){
		// otherwise we scan up or down from cache_chunk
		if(!cache_chunk) cache_chunk = last_chunk
		while(cache_chunk && off < cache_chunk.accum_off){
			cache_chunk = chunk_list[cache_chunk.chunk_id -1]
		}
		while(cache_chunk && off >= cache_chunk.accum_off + cache_chunk.char_off){
			cache_chunk = chunk_list[cache_chunk.chunk_id + 1]
		}
		if(!cache_chunk) cache_chunk = last_chunk
		return cache_chunk
	}

	charTag_z(off){
		var chunk = findChunk(off)
		return chunk.charTag_z(off - chunk.accum_off)
	}

	reserialize(){
		var str
		for(var chunk from chunk_list){
			str += chunk.reserialize()
		}
		return str
	}

	charBaseline(off){
		var chunk = findChunk(off)
		return chunk.charBaseline(off - chunk.accum_off) + chunk.y
	}
	
	reallocText(extra){
		//last_chunk.reallocText(extra)
	}

	allocText(length){
		//last_chunk.allocText(length)
	}

	updateText(){
		last_chunk.updateText()
	}

	tagChar(off, length, x, y, z){
		last_chunk.tagChar(off, length, x, y, z)
	}

	newline(t){
		char_off += last_chunk.newline(t)
		if(last_chunk.lines > chunk_lines){
			last_chunk.updateText()
			var new_chunk = this.Chunk.new(this)
			// complete last_chunk
			add_y += last_chunk.add_y
			new_chunk.accum_off = last_chunk.char_off + last_chunk.accum_off
			new_chunk.chunk_id = chunk_list.length - 1
			new_chunk.y = add_y 
			last_chunk = new_chunk
			last_chunk.allocText(default_alloc)
		}
	}

	tab(t){
		char_off += last_chunk.tab(t)
	}

	space(t){
		char_off += last_chunk.space(t)
	}

	string(text, x, y){
		// lets add text to our last last_chunk
		last_chunk.tag_x = tag_x
		last_chunk.tag_y = tag_y
		char_off += last_chunk.string(text, x, y)
	}

	addMarkers(start, end){
		chunk_list[0].allocMarkers(100)
		chunk_list[0].addMarkers(start, end)
	}

	clearMarkers(){
		chunk_list[0].clearMarkers()
	}

	updateText(){
		chunk_list[0].updateText()
	}
}