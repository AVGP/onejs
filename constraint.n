// Parts Copyright (C) 1998-2000 Greg J. Badros
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)
// Parts Copyright (C) 2014 OneJS
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

class CS{
	
	// OneJS glue api

	class ASTWalker{

		follow( n ){
			if(!this[n.type]) throw new Error('Node type ' + n.type + ' not supported in constraint')
			return this[n.type](n)
		}

		Id( n ){
			var name = n.name
			var v = Variable.new({name:name + context.proxy_uid, value:context[name]})

			var signame = 'on_' + name
			if(!context[signame]){
				context.signal(name)
			}
			v._sig = context[signame]
			context[signame]._var = v
			return v
		}

		Value( n ){
			return n.value
		}

		Key( n ){
			
		}

		Binary( n ){
			var left = this.follow(n.left)
			var right = this.follow(n.right)
			if(n.op == '*') return CS.times(left, right)
			if(n.op == '+') return CS.plus(left, right)
			if(n.op == '-') return CS.minus(left, right)
			if(n.op == '/') return CS.divide(left, right)
			throw new Error('Operation not supported for constraint '+ n)
		}

		Logic( n ){
			var left = this.follow(n.left)
			var right = this.follow(n.right)
			if(n.op == '=='){
				return Equation.new(left, right, Strength.weak, 0)
			}
			if(n.op == '<' || n.op == '<='){
				return Inequality.new(left, CS.LEQ, right, Strength.weak, 0)
			}
			if(n.op == '>' || n.op == '>='){
				return Inequality.new(left, CS.GEQ, right, Strength.weak, 0)
			}
			throw new Error('Operation not supported for constraint ' + n)
		}
	}

	ASTNodeToConstraint(context, ast){
		if(ast.type != 'Logic') throw new Error('Only support type=logic '+ast)
		// allright. lets recursively walk the AST and spawn up our constraint system
		ASTWalker.context = context
		return ASTWalker.follow(ast)
	}

	var epsilon = 1e-8

	debug = false
	trace = false
	verbose = false
	traceAdded = false
	GC = false
	GEQ = 1
	LEQ = 2

	traceprint(s /*String*/){ if (CS.verbose){ console.log(s) } }
	fnenterprint(s /*String*/){ console.log("* " + s) }
	fnexitprint(s /*String*/){ console.log("- " + s) }

	// NOPE none of this.
	own(obj, cb, context){
		Object.getOwnPropertyNames(obj).forEach(cb, context||scope)
		return obj
	}

	function exprFromVarOrValue(v){
		if (typeof v == "number" ){
			return Expression.fromConstant(v)
		} 
		else if(CS.Variable.isPrototypeOf(v)){
			return Expression.fromVariable(v)
		}
		return v
	}

	plus(e1, e2){
		e1 = exprFromVarOrValue(e1)
		e2 = exprFromVarOrValue(e2)
		return e1.plus(e2)
	}

	minus(e1, e2){
		e1 = exprFromVarOrValue(e1)
		e2 = exprFromVarOrValue(e2)
		return e1.minus(e2)
	}

	times(e1, e2){
		e1 = exprFromVarOrValue(e1)
		e2 = exprFromVarOrValue(e2)
		return e1.times(e2)
	}

	divide(e1, e2){
		e1 = exprFromVarOrValue(e1)
		e2 = exprFromVarOrValue(e2)
		return e1.divide(e2)
	}

	approx(a, b){
		if (a === b) return true
		a = +(a)
		b = +(b)
		if (a == 0) return (Math.abs(b) < epsilon)
		if (b == 0) return (Math.abs(a) < epsilon)
		return (Math.abs(a - b) < Math.abs(a) * epsilon)
	}

	var count = 1
	_inc(){
		return count++
	}

	class EditInfo{
	  constructor(cn /*CS.Constraint*/, eplus   /*CS.SlackVariable*/, eminus  /*CS.SlackVariable*/, prevEditConstant /*double*/, i /*int*/) {
		this.constraint = cn
		this.editPlus = eplus
		this.editMinus = eminus
		this.prevEditConstant = prevEditConstant
		this.index = i
	  }
	  toString() {
		return "<cn=" + this.constraint +
			   ", ep=" + this.editPlus +
			   ", em=" + this.editMinus +
			   ", pec=" + this.prevEditConstant +
			   ", index=" + this.index + ">"
	  }
	}

	class CSError{
		constructor(s /*String*/) { if (s) { this._description = s } }

		_description = "An error has occured in Cassowary"

		set description(v)   { this._description = v }
		get description()    { return "(" + this.__class__ + ") " + this._description }
		get message()        { return this.description }
		toString(){ return this.description }
	}

	class ConstraintNotFound extends CSError{
		_description = "Tried to remove a constraint never added to the tableu"
	}

	class InternalError extends CSError{
		_description = "InternalError"
	}

	class NonExpression extends CSError{
		_description = "The resulting expression would be non"
	}

	class NotEnoughStays extends CSError{
		_description = "There are not enough stays to give specific values to every variable"
	}

	class RequiredFailure extends CSError{
		_description = "A required constraint cannot be satisfied"
	}

	class TooDifficult extends CSError{
		_description = "The constraints are too difficult to solve"
	}

	class AbstractConstraint{

		constructor(strength /*CS.Strength*/, weight /*double*/){
			this.hashCode = CS._inc()
			this.strength = strength || Strength.required
			this.weight = weight || 1;
		},

		isEditConstraint = false
		isInequality = false
		isStayConstraint = false

		get isRequired(){ return (this.strength === Strength.required) }

		toString(){
			return this.strength + " {" + this.weight + "} (" + this.expression +")";
		}
	}

	class EditConstraint extends AbstractConstraint{
		constructor(cv, strength = Strength.strong, weight){
			AbstractConstraint::constructor(strength, weight)
			variable  = cv
			expression = Expression.new(cv, -1, cv.value)
		}
		isEditConstraint = true

		toString(){
			return "edit:"+ AbstractConstraint::toString()
		}
	}

	class StayConstraint extends AbstractConstraint{
		constructor(cv, strength = Strength.strong, weight){
			AbstractConstraint::constructor(strength, weight)
			variable  = cv
			expression = Expression.new(cv, -1, cv.value)
		}	
		isStayConstraint = true
		toString(){
			return "stay:"+ AbstractConstraint::toString()
		}
	}

	class Constraint extends AbstractConstraint{
		constructor(cle, strength, weight){
			AbstractConstraint::constructor(strength, weight)
			expression = cle
		}
	}

	class Inequality extends Constraint{

		_cloneOrNewCle(cle){
			// FIXME(D4): move somewhere else?
			if (cle.clone)  {
				return cle.clone()
			} 
			else {
				return Expression.new(cle)
			}
		}

		constructor(a1, a2, a3, a4, a5){
			// FIXME(slightlyoff): what a disgusting mess. Should at least add docs.
			// console.log("CS.Inequality.initialize(", a1, a2, a3, a4, a5, ")");

			var a1IsExp = Expression.isPrototypeOf(a1),
				a3IsExp = Expression.isPrototypeOf(a3),
				a1IsVar = AbstractVariable.isPrototypeOf(a1),
				a3IsVar = AbstractVariable.isPrototypeOf(a3),
				a1IsNum = typeof(a1) == 'number',
				a3IsNum = typeof(a3) == 'number'

			if ((a1IsExp || a1IsNum) && a3IsVar){
				var cle = a1, op = a2, cv = a3, strength = a4, weight = a5

				Constraint::constructor(_cloneOrNewCle(cle), strength, weight)

				if (op == CS.LEQ){
					this.expression.multiplyMe(-1)
					this.expression.addVariable(cv)
				}
				else if (op == CS.GEQ){
					this.expression.addVariable(cv, -1)
				} 
				else {
					throw InternalError.new("Invalid operator in CS.Inequality constructor");
				}
			// cv, op, (cle || number)
			} 
			else if (a1IsVar && (a3IsExp || a3IsNum)){
				var cle = a3, op = a2, cv = a1, strength = a4, weight = a5
				Constraint::constructor(_cloneOrNewCle(cle), strength, weight)

				if (op == CS.GEQ){
					this.expression.multiplyMe(-1)
					this.expression.addVariable(cv)
				} 
				else if (op == CS.LEQ){
					this.expression.addVariable(cv, -1)
				} 
				else {
					throw InternalError.new("Invalid operator in CS.Inequality constructor");
				}
			// cle, op, num
			} 
			else if (a1IsExp && a3IsNum){
				var cle1 = a1, op = a2, cle2 = a3, strength = a4, weight = a5
				Constraint::constructor(_cloneOrNewCle(cle1), strength, weight)
				if (op == CS.LEQ){
					this.expression.multiplyMe(-1)
					this.expression.addExpression(this._cloneOrNewCle(cle2))
				} 
				else if (op == CS.GEQ){
					this.expression.addExpression(this._cloneOrNewCle(cle2), -1)
				} 
				else {
					throw InternalError.new("Invalid operator in CS.Inequality constructor");
				}
			// num, op, cle
			} 
			else if (a1IsNum && a3IsExp){
				var cle1 = a3, op = a2, cle2 = a1, strength = a4, weight = a5
				Constraint::constructor(_cloneOrNewCle(cle1), strength, weight)
				if (op == CS.GEQ){
					this.expression.multiplyMe(-1);
					this.expression.addExpression(this._cloneOrNewCle(cle2))
				} 
				else if (op == CS.LEQ){
					this.expression.addExpression(this._cloneOrNewCle(cle2), -1)
				} 
				else {
					throw InternalError.new("Invalid operator in CS.Inequality constructor")
				}
			// cle op cle
			} 
			else if (a1IsExp && a3IsExp){
				var cle1 = a1, op = a2, cle2 = a3, strength = a4, weight = a5
				Constraint::constructor(_cloneOrNewCle(cle2), strength, weight)
				if (op == CS.GEQ){
					this.expression.multiplyMe(-1)
					this.expression.addExpression(this._cloneOrNewCle(cle1))
				} 
				else if (op == CS.LEQ){
					this.expression.addExpression(this._cloneOrNewCle(cle1), -1)
				} 
				else {
					throw InternalError.new("Invalid operator in CS.Inequality constructor");
				}
			// cle
			} 
			else if (a1IsExp){
				Constraint::constructor(a1, a2, a3)
			// >=
			} 
			else if (a2 == CS.GEQ){
				Constraint::constructor(Expression.new(a3), a4, a5)
				this.expression.multiplyMe(-1)
				this.expression.addVariable(a1)
			// <=
			} 
			else if (a2 == CS.LEQ){
				Constraint::constructor(Expression.new(a3), a4, a5)
				this.expression.addVariable(a1, -1)
			// error
			} 
			else {
				throw InternalError.new("Invalid operator in CS.Inequality constructor");
			}
		}

		isInequality = true

		toString(){
			return Constraint::toString() + " >= 0) id: " + this.hashCode
		}
	}

	class Equation extends Constraint{

		constructor(a1, a2, a3, a4){
			// FIXME(slightlyoff): this is just a huge mess.
			if (Expression.isPrototypeOf(a1) && !a2 || Strength.isPrototypeOf(a2)){
				Constraint::constructor(a1, a2, a3)
			} 
			else if (AbstractVariable.isPrototypeOf(a1) &&
				Expression.isPrototypeOf(a2)){

				var cv = a1, cle = a2, strength = a3, weight = a4
				Constraint::constructor( cle.clone, strength, weight)
				this.expression.addVariable(cv, -1)
			} 
			else if (AbstractVariable.isPrototypeOf(a1) &&
				typeof(a2) == 'number'){

				var cv = a1, val = a2, strength = a3, weight = a4
				Constraint::constructor( Expression.new(val), strength, weight)
				this.expression.addVariable(cv, -1)
			} 
			else if (Expression.isPrototypeOf(a1) &&
					AbstractVariable.isPrototypeOf(a2)){

				var cle = a1, cv = a2, strength = a3, weight = a4
				Constraint::constructor(cle.clone(), strength, weight)
				this.expression.addVariable(cv, -1)
			} 
			else if ((Expression.isPrototypeOf(a1) || AbstractVariable.isPrototypeOf(a1) || typeof(a1) == 'number') &&
					 (Expression.isPrototypeOf(a2) || AbstractVariable.isPrototypeOf(a2) || typeof(a2) == 'number')){

				if (Expression.isPrototypeOf(a1)){
					a1 = a1.clone()
				} 
				else {
					a1 = Expression.new(a1)
				}

				if (Expression.isPrototypeOf(a2)){
					a2 = a2.clone()
				} 
				else {
					a2 = Expression.new(a2)
				}
				Constraint::constructor(a1, a3, a4)
				this.expression.addExpression(a2, -1)

			} 
			else {
				throw "Bad initializer to CS.Equation";
			}
			assert(Strength.isPrototypeOf(this.strength))
		}

		toString(){
			return Constraint::toString() + " = 0)"
		}
	}

	function checkNumber(value, otherwise){
		// if(isNaN(value)){ debugger; }
		return (typeof value === "number") ? value : otherwise
	}

	class Expression{

		constructor(cvar /*CS.AbstractVariable*/, value /*double*/, constant /*double*/){

			this.constant = checkNumber(constant, 0)
			this.terms = HashTable.new()

			if (AbstractVariable.isPrototypeOf(cvar)){
				value = checkNumber(value, 1)
				this.setVariable(cvar, value)
			}
			else if (typeof cvar == "number"){
				if (!isNaN(cvar)){
					this.constant = cvar
				} 
				else {
					console.trace()
				}
			}
		}

		empty(){
			return new(undefined, 1, 0)
		}

		fromConstant(cons){
			return new(cons)
		}

		fromValue(v){
			v = +(v)
			return new(undefined, v, 0)
		}

		fromVariable(v){
			return new(v, 1, 0)
		}

		initializeFromHash(constant /*ClDouble*/, terms /*CS.Hashtable*/){
			if (CS.verbose){
				console.log("*******************************");
				console.log("clone CS.initializeFromHash");
				console.log("*******************************");
			}

			if (CS.GC) console.log("clone CS.Expression");
			this.constant = constant
			this.terms = terms.clone()
		}

		multiplyMe(x /*double*/){
			this.constant *= x
			var t = this.terms
			t.each(function(clv, coeff){ t.set(clv, coeff * x) })
			return this
		}

		clone(){
			if (CS.verbose){
				console.log("*******************************")
				console.log("clone CS.Expression")
				console.log("*******************************")
			}

			var e = CS.Expression.empty()
			e.initializeFromHash(this.constant, this.terms)
			return e
		}

		times(x){
			if (typeof x == 'number'){
				return (this.clone()).multiplyMe(x)
			} 
			else {
				if (this.isConstant){
					return x.times(this.constant)
				} 
				else if (x.isConstant){
					return this.times(x.constant)
				} 
				else {
					throw NonExpression.new()
				}
			}
		}

		plus(expr /*CS.Expression*/){
			if (Expression.isPrototypeOf(expr)){
				return this.clone().addExpression(expr, 1)
			} 
			else if (Variable.isPrototypeOf(expr)){
				return this.clone().addVariable(expr, 1)
			}
		}

		minus(expr /*CS.Expression*/){
			if (Expression.isPrototypeOf(expr)){
				return this.clone().addExpression(expr, -1)
			} 
			else if (Variable.isPrototypeOf(expr)){
				return this.clone().addVariable(expr, -1)
			}
		}

		divide(x){
			if (typeof x == 'number'){
				if (CS.approx(x, 0)){
					throw NonExpression.new()
				}
				return this.times(1 / x);
			} 
			else if (x instanceof CS.Expression){
				if (!x.isConstant){
					throw NonExpression.new()
				}
				return this.times(1 / x.constant)
			}
		}

		addExpression(expr /*CS.Expression*/, n /*double*/, subject /*CS.AbstractVariable*/, solver /*CS.Tableau*/){

			// console.log("CS.Expression::addExpression()", expr, n);
			// console.trace();
			if (AbstractVariable.isPrototypeOf(expr)){
				expr = CS.Expression.fromVariable(expr)
				// if(CS.trace) console.log("addExpression: Had to cast a var to an expression");
			}
			n = checkNumber(n, 1)
			this.constant += (n * expr.constant)
			expr.terms.each(function(clv, coeff){
				// console.log("clv:", clv, "coeff:", coeff, "subject:", subject);
				this.addVariable(clv, coeff * n, subject, solver)
			}, this)
			return this
		}

		addVariable(v /*CS.AbstractVariable*/, cd /*double*/, subject, solver){
			if (cd == null){
				cd = 1
			}

			/*
			if (CS.trace) console.log("CS.Expression::addVariable():", v , cd);
			*/
			var coeff = this.terms.get(v)
			if (coeff){
				var newCoefficient = coeff + cd
				if (newCoefficient == 0 || CS.approx(newCoefficient, 0)){
					if (solver){
						solver.noteRemovedVariable(v, subject)
					}
					this.terms.delete(v)
				} 
				else {
					this.setVariable(v, newCoefficient)
				}
			} 
			else {
				if (!CS.approx(cd, 0)){
					this.setVariable(v, cd)
					if (solver){
						solver.noteAddedVariable(v, subject)
					}
				}
			}
			return this
		}

		setVariable(v /*CS.AbstractVariable*/, c /*double*/){
			// console.log("terms.set(", v, c, ")");
			this.terms.set(v, c)
			return this
		}

		anyPivotableVariable(){
			if (this.isConstant){
				throw InternalError.new("anyPivotableVariable called on a constant")
			}

			var rv = this.terms.escapingEach(function(clv, c){
				if (clv.isPivotable) return { retval: clv }
			})

			if(rv && rv.retval !== undefined){
				return rv.retval
			}

			return null
		}

		substituteOut(outvar  /*CS.AbstractVariable*/, expr    /*CS.Expression*/, subject /*CS.AbstractVariable*/, solver  /*ClTableau*/){
			/*
			if (CS.trace){
				CS.fnenterprint("CLE:substituteOut: " + outvar + ", " + expr + ", " + subject + ", ...");
				CS.traceprint("this = " + this);
			}
			*/
			var setVariable = this.setVariable.bind(this)
			var terms = this.terms
			var multiplier = terms.get(outvar)
			terms.delete(outvar)
			this.constant += (multiplier * expr.constant)
			/*
			console.log("substituteOut:",
									"\n\toutvar:", outvar,
									"\n\texpr:", expr.toString(),
									"\n\tmultiplier:", multiplier,
									"\n\tterms:", terms);
			*/
			expr.terms.each(function(clv, coeff){
				var oldCoefficient = terms.get(clv)
				if (oldCoefficient){
					var newCoefficient = oldCoefficient + multiplier * coeff
					if (CS.approx(newCoefficient, 0)){
						solver.noteRemovedVariable(clv, subject)
						terms.delete(clv)
					} else {
						terms.set(clv, newCoefficient)
					}
				} else {
					terms.set(clv, multiplier * coeff)
					if (solver){
						solver.noteAddedVariable(clv, subject)
					}
				}
			})
			// if (CS.trace) CS.traceprint("Now this is " + this);
		}

		changeSubject(old_subject /*CS.AbstractVariable*/, new_subject /*CS.AbstractVariable*/){
			this.setVariable(old_subject, this.newSubject(new_subject))
		}

		newSubject(subject /*CS.AbstractVariable*/){
			// if (CS.trace) CS.fnenterprint("newSubject:" + subject);
			var reciprocal = 1 / this.terms.get(subject)
			this.terms.delete(subject)
			this.multiplyMe(-reciprocal)
			return reciprocal
		}

		// Return the coefficient corresponding to variable var, i.e.,
		// the 'ci' corresponding to the 'vi' that var is:
		//     v1*c1 + v2*c2 + .. + vn*cn + c
		coefficientFor(clv /*CS.AbstractVariable*/){
			return this.terms.get(clv) || 0
		}

		get isConstant(){
			return this.terms.size == 0
		}

		toString(){
			var bstr = ''; // answer
			var needsplus = false
			if (!CS.approx(this.constant, 0) || this.isConstant){
				bstr += this.constant
				if (this.isConstant){
					return bstr
				} else {
					needsplus = true
				}
			}
			this.terms.each( function(clv, coeff){
				if (needsplus){
					bstr += " + "
				}
				bstr += coeff + "*" + clv
				needsplus = true;
			});
			return bstr
		}

		equals(other){
			if (other === this){
				return true
			}

			return Expression.isPrototypeOf(other) &&
				   other.constant === this.constant &&
				   other.terms.equals(this.terms)
		}

		Plus(e1 /*CS.Expression*/, e2 /*CS.Expression*/){
			return e1.plus(e2)
		}

		Minus(e1 /*CS.Expression*/, e2 /*CS.Expression*/){
			return e1.minus(e2)
		}

		Times(e1 /*CS.Expression*/, e2 /*CS.Expression*/){
			return e1.times(e2)
		}

		Divide(e1 /*CS.Expression*/, e2 /*CS.Expression*/){
			return e1.divide(e2)
		}

	}

	class HashSet{

		constructor(){
			this.storage = []
			this.size = 0
			this.hashCode = CS._inc()
		}

		add(item){
			var s = this.storage, io = s.indexOf(item)
			if (s.indexOf(item) == -1) s[s.length] = item
			this.size = this.storage.length
		}

		values(){
			// FIXME(slightlyoff): is it safe to assume we won't be mutated by our caller?
			//                     if not, return this.storage.slice(0);
			return this.storage
		}

		has(item){
			var s = this.storage
			return (s.indexOf(item) != -1)
		}

		this.delete(item){
			var io = this.storage.indexOf(item)
			if (io == -1){ return null; }
			this.storage.splice(io, 1)[0]
			this.size = this.storage.length
		}

		clear(){
			this.storage.length = 0
		}

		each(func, scope){
			if(this.size)
				this.storage.forEach(func, scope)
		}

		escapingEach(func, scope){
			// FIXME(slightlyoff): actually escape!
			if (this.size)
				this.storage.forEach(func, scope)
		}

		toString(){
			var answer = this.size + " {"
			var first = true
			this.each(function(e){
				if (!first){
					answer += ", "
				} 
				else {
					first = false
				}
				answer += e
			})
			answer += "}\n"
			return answer
		}
	}

	// For escapingEach
	var defaultContext = {}

	class HashTable{

		constructor(){
			this.size = 0
			this._store = {}
			this._keyStrMap = {}
			this._deleted = 0
		}

		set(key, value){
			var hash = key.hashCode
			if (typeof this._store[hash] == "undefined"){
				// FIXME(slightlyoff): if size gooes above the V8 property limit,
				// compact or go to a tree.
				this.size++
			}
			this._store[hash] = value
			this._keyStrMap[hash] = key
		}

		get(key){
			if(!this.size) return null

			key = key.hashCode

			var v = this._store[key]
			if (typeof v != "undefined"){
				return this._store[key]
			}
			return null
		}

		function copyOwn(src, dest) {
		  Object.keys(src).forEach(function(x) {
		    dest[x] = src[x]
		  })
		}

		clear(){
			this.size = 0
			this._store = {}
			this._keyStrMap = {}
		}

		_compact(){
			// console.time("HashTable::_compact()");
			var ns = {}
			copyOwn(this._store, ns)
			this._store = ns
			// console.timeEnd("HashTable::_compact()");
		}

		_compactThreshold = 100

		_perhapsCompact(){
			// If we have more properties than V8's fast property lookup limit, don't
			// bother
			if (this._size > 30) return
			if (this._deleted > this._compactThreshold){
				this._compact()
				this._deleted = 0
			}
		}

		this.delete(key){
			key = key.hashCode
			if (!this._store.hasOwnProperty(key)){
				return
			}
			this._deleted++

			// FIXME(slightlyoff):
			//    I hate this because it causes these objects to go megamorphic = (
			//    Sadly, Cassowary is hugely sensitive to iteration order changes, and
			//    "delete" preserves order when Object.keys() is called later.
			delete this._store[key]
			// Note: we don't delete from _keyStrMap because we only get the
			// Object.keys() from _store, so it's the only one we need to keep up-to-
			// date.

			if (this.size > 0){
				this.size--
			}
		}

		each(callback, scope){
			if (!this.size) return

			this._perhapsCompact()

			var store = this._store
			var keyMap = this._keyStrMap
			for (var x in this._store){
				if (this._store.hasOwnProperty(x)){
					callback.call(scope||null, keyMap[x], store[x])
				}
			}
		}

		escapingEach(callback, scope){
			if (!this.size) return

			this._perhapsCompact()

			var that = this
			var store = this._store
			var keyMap = this._keyStrMap
			var context = defaultContext
			var kl = Object.keys(store)
			for (var x = 0; x < kl.length; x++){
				(function(v){
					if (that._store.hasOwnProperty(v)){
						context = callback.call(scope||null, keyMap[v], store[v])
					}
				})(kl[x])

				if (context){
					if (context.retval !== undefined){
						return context
					}
					if (context.brk){
						break
					}
				}
			}
		}

		clone(){
			var n = HashTable.new()
			if (this.size){
				n.size = this.size
				copyOwn(this._store, n._store)
				copyOwn(this._keyStrMap, n._keyStrMap)
			}
			return n
		}

		equals(other){
			if (other === this){
				return true
			}

			if (!HashTable.isPrototypeOf(other) || other._size !== this._size){
				return false
			}

			var codes = Object.keys(this._store)
			for (var i = 0; i < codes.length; i++){
				var code = codes[i]
				if (this._keyStrMap[code] !== other._keyStrMap[code] ||
						this._store[code] !== other._store[code]){
					return false
				}
			}

			return true
		}

		toString(h){
			var answer = ""
			this.each(function(k, v){ answer += k + " => " + v + "\n" })
			return answer
		}
	}

	class Point{
		constructor(x, y, suffix){
			if (Variable.isPrototypeOf(x)){
				this._x = x
			} 
			else {
				var xArgs = { value: x }
				if (suffix){
					xArgs.name = "x" + suffix
				}
				this._x = Variable.new(xArgs)
			}
			if (Variable.isPrototypeOf(y)){
				this._y = y
			} 
			else {
				var yArgs = { value: y }
				if (suffix){
					yArgs.name = "y" + suffix
				}
				this._y = Variable.new(yArgs)
			}
		}

		get x(){ return this._x }
		set x(xVar){
			if (Variable.isPrototypeOf(xVar)){
				this._x = xVar
			} 
			else {
				this._x.value = xVar
			}
		}

		get y(){ return this._y }
		set y(yVar){
			if (Variable.isPrototypeOf(yVar)){
				this._y = yVar
			} 
			else {
				this._y.value = yVar
			}
		}

		toString(){
			return "(" + this.x + ", " + this.y + ")"
		}
	}


	class Tableau{
		constructor(){
			// columns is a mapping from variables which occur in expressions to the
			// set of basic variables whose expressions contain them
			// i.e., it's a mapping from variables in expressions (a column) to the
			// set of rows that contain them
			this.columns = HashTable.new() // values are sets

			// _rows maps basic variables to the expressions for that row in the tableau
			this.rows = HashTable.new()    // values are CS.Expressions

			// the collection of basic variables that have infeasible rows
			// (used when reoptimizing)
			this._infeasibleRows = HashSet.new()

			// the set of rows where the basic variable is external this was added to
			// the C++ version to reduce time in setExternalVariables()
			this._externalRows = HashSet.new()

			// the set of external variables which are parametric this was added to the
			// C++ version to reduce time in setExternalVariables()
			this._externalParametricVars = HashSet.new()
		}

		// Variable v has been removed from an Expression.  If the Expression is in a
		// tableau the corresponding basic variable is subject (or if subject is nil
		// then it's in the objective function). Update the column cross-indices.
		noteRemovedVariable(v /*CS.AbstractVariable*/, subject /*CS.AbstractVariable*/){
			CS.trace && console.log("CS.Tableau::noteRemovedVariable: ", v, subject)
			var column = this.columns.get(v)
			if (subject && column){
				column.delete(subject)
			}
		}

		noteAddedVariable(v /*CS.AbstractVariable*/, subject /*CS.AbstractVariable*/){
			// if (CS.trace) console.log("CS.Tableau::noteAddedVariable:", v, subject);
			if (subject){
				this.insertColVar(v, subject)
			}
		}

		getInternalInfo(){
			var retstr = "Tableau Information:\n"
			retstr += "Rows: " + this.rows.size
			retstr += " (= " + (this.rows.size - 1) + " constraints)"
			retstr += "\nColumns: " + this.columns.size
			retstr += "\nInfeasible Rows: " + this._infeasibleRows.size
			retstr += "\nExternal basic variables: " + this._externalRows.size
			retstr += "\nExternal parametric variables: "
			retstr += this._externalParametricVars.size
			retstr += "\n"
			return retstr
		}

		toString(){
			var bstr = "Tableau:\n"
			this.rows.each(function(clv, expr){
				bstr += clv
				bstr += " <==> "
				bstr += expr
				bstr += "\n"
			})
			bstr += "\nColumns:\n"
			bstr += this.columns
			bstr += "\nInfeasible rows: "
			bstr += this._infeasibleRows
			bstr += "External basic variables: "
			bstr += this._externalRows
			bstr += "External parametric variables: "
			bstr += this._externalParametricVars
			return bstr
		}

		/*
		toJSON: function(){
			// Creates an object representation of the Tableau.
		},
		*/

		// Convenience function to insert a variable into
		// the set of rows stored at columns[param_var],
		// creating a new set if needed
		insertColVar(param_var /*CS.Variable*/, rowvar /*CS.Variable*/){
			var rowset = /* Set */ this.columns.get(param_var)
			if (!rowset){
				rowset = HashSet.new()
				this.columns.set(param_var, rowset)
			}
			rowset.add(rowvar)
		}

		addRow(aVar /*CS.AbstractVariable*/, expr /*CS.Expression*/){
			if (CS.trace) CS.fnenterprint("addRow: " + aVar + ", " + expr)
			this.rows.set(aVar, expr)
			expr.terms.each(function(clv, coeff){
				this.insertColVar(clv, aVar)
				if (clv.isExternal){
					this._externalParametricVars.add(clv)
				}
			}, this)
			if (aVar.isExternal){
				this._externalRows.add(aVar)
			}
			if (CS.trace) CS.traceprint(this.toString())
		}

		removeColumn(aVar /*CS.AbstractVariable*/){
			if (CS.trace) CS.fnenterprint("removeColumn:" + aVar)
			var rows = /* Set */ this.columns.get(aVar)
			if (rows){
				this.columns.delete(aVar)
				rows.each(function(clv){
					var expr = /* CS.Expression */this.rows.get(clv)
					expr.terms.delete(aVar)
				}, this)
			} 
			else {
				if (CS.trace) console.log("Could not find var", aVar, "in columns")
			}
			if (aVar.isExternal){
				this._externalRows.delete(aVar)
				this._externalParametricVars.delete(aVar)
			}
		}

		removeRow(aVar /*CS.AbstractVariable*/){
			if (CS.trace) CS.fnenterprint("removeRow:" + aVar)
			var expr = /* CS.Expression */this.rows.get(aVar)
			assert(expr != null)
			expr.terms.each(function(clv, coeff){
				var varset = this.columns.get(clv)
				if (varset != null){
					if (CS.trace) console.log("removing from varset:", aVar)
					varset.delete(aVar)
				}
			}, this)
			this._infeasibleRows.delete(aVar)
			if (aVar.isExternal){
				this._externalRows.delete(aVar)
			}
			this.rows.delete(aVar)
			if (CS.trace) CS.fnexitprint("returning " + expr)
			return expr
		}

		substituteOut(oldVar /*CS.AbstractVariable*/, expr /*CS.Expression*/){
			if (CS.trace) CS.fnenterprint("substituteOut:" + oldVar + ", " + expr)
			if (CS.trace) CS.traceprint(this.toString())

			var varset = this.columns.get(oldVar)
			varset.each(function(v){
				var row = this.rows.get(v)
				row.substituteOut(oldVar, expr, v, this)
				if (v.isRestricted && row.constant < 0){
					this._infeasibleRows.add(v)
				}
			}, this)

			if (oldVar.isExternal){
				this._externalRows.add(oldVar)
				this._externalParametricVars.delete(oldVar)
			}

			this.columns.delete(oldVar)
		}

		columnsHasKey(subject /*CS.AbstractVariable*/){
			return !!this.columns.get(subject)
		}
	}

	class SimplexSolver extends Tableau{

		constructor(){
			Tableau::constructor()

			this._stayMinusErrorVars = []
			this._stayPlusErrorVars = []

			this._errorVars = HashTable.new() // cn -> Set of cv

			this._markerVars = HashTable.new() // cn -> Set of cv

			// this._resolve_pair = [0, 0];
			this._objective = ObjectiveVariable.new({ name: "Z" })

			this._editVarMap = HashTable.new() // cv -> CS.EditInfo
			this._editVarList = []

			this._slackCounter = 0
			this._artificialCounter = 0
			this._dummyCounter = 0
			this.autoSolve = false
			this._needsSolving = false

			this._optimizeCount = 0

			this.rows.set(this._objective, Expression.empty())
			this._editVariableStack = [0] // Stack
			if (CS.trace)
				CS.traceprint("objective expr == " + this.rows.get(this._objective))
		}

		add(/*CS.Constraint, ...*/){
			for (var x = 0; x < arguments.length; x++){
				this.addConstraint(arguments[x])
			}
			return this
		}

		_addEditConstraint(cn, eplus_eminus, prevEConstant){
				var i = this._editVarMap.size
				var cvEplus = /* CS.SlackVariable */eplus_eminus[0]
				var cvEminus = /* CS.SlackVariable */eplus_eminus[1]
				/*
				if (!cvEplus instanceof CS.SlackVariable){
					console.warn("cvEplus not a slack variable =", cvEplus);
				}
				if (!cvEminus instanceof CS.SlackVariable){
					console.warn("cvEminus not a slack variable =", cvEminus);
				}
				CS.debug && console.log("new CS.EditInfo(" + cn + ", " + cvEplus + ", " +
																		cvEminus + ", " + prevEConstant + ", " +
																		i +")");
				*/
				var ei = EditInfo.new(cn, cvEplus, cvEminus, prevEConstant, i)
				this._editVarMap.set(cn.variable, ei)
				this._editVarList[i] = { v: cn.variable, info: ei }
		}

		addConstraint(cn /*CS.Constraint*/){
			CS.trace && CS.fnenterprint("addConstraint: " + cn)
			var eplus_eminus = new Array(2)
			var prevEConstant = new Array(1) // so it can be output to
			var expr = this.newExpression(cn, /*output to*/ eplus_eminus, prevEConstant)
			prevEConstant = prevEConstant[0]

			if (!this.tryAddingDirectly(expr)){
				this.addWithArtificialVariable(expr)
			}


			this._needsSolving = true
			if (cn.isEditConstraint){
				this._addEditConstraint(cn, eplus_eminus, prevEConstant)
			}
			if (this.autoSolve){
				this.optimize(this._objective)
				this._setExternalVariables()
			}
			return this
		}

		addConstraintNoException(cn /*CS.Constraint*/){
			CS.trace && CS.fnenterprint("addConstraintNoException: " + cn)
			// FIXME(slightlyoff): change this to enable chaining
			try {
				this.addConstraint(cn)
				return true
			} catch (e /*CS.RequiredFailure*/){
				return false
			}
		}

		addEditVar(v /*CS.Variable*/, strength /*CS.Strength*/, weight /*double*/){
			CS.trace && CS.fnenterprint("addEditVar: " + v + " @ " + strength + " {" + weight + "}")
			return this.addConstraint(EditConstraint.new(v, strength || Strength.strong, weight))
		}

		beginEdit(){
			// FIXME(slightlyoff): we shouldn't throw here. Log instead
			assert(this._editVarMap.size > 0)
			this._infeasibleRows.clear()
			this._resetStayConstants()
			this._editVariableStack[this._editVariableStack.length] = this._editVarMap.size
			return this
		}

		endEdit(){
			// FIXME(slightlyoff): we shouldn't throw here. Log instead
			assert(this._editVarMap.size > 0)
			this.resolve()
			this._editVariableStack.pop()
			this.removeEditVarsTo(
				this._editVariableStack[this._editVariableStack.length - 1]
			)
			return this
		}

		removeAllEditVars(){
			return this.removeEditVarsTo(0)
		}

		removeEditVarsTo(n /*int*/){
			try {
				var evll = this._editVarList.length
				// only remove the variable if it's not in the set of variable
				// from a previous nested outer edit
				// e.g., if I do:
				// Edit x,y
				// Edit w,h,x,y
				// EndEdit
				// The end edit needs to only get rid of the edits on w,h
				// not the ones on x,y
				for(var x = n; x < evll; x++){
					if (this._editVarList[x]){
						this.removeConstraint(
							this._editVarMap.get(this._editVarList[x].v).constraint
						)
					}
				}
				this._editVarList.length = n
				assert(this._editVarMap.size == n)
				return this
			} 
			catch (e /*ConstraintNotFound*/){
				throw InternalError.new("Constraint not found in removeEditVarsTo");
			}
		}

		// Add weak stays to the x and y parts of each point. These have
		// increasing weights so that the solver will try to satisfy the x
		// and y stays on the same point, rather than the x stay on one and
		// the y stay on another.
		addPointStays(points /*[{ x: .., y: ..}, ...]*/){
			CS.trace && console.log("addPointStays", points)
			points.forEach(function(p, idx){
				this.addStay(p.x, Strength.weak, Math.pow(2, idx))
				this.addStay(p.y, Strength.weak, Math.pow(2, idx))
			}, this)
			return this
		}

		addStay(v /*CS.Variable*/, strength /*CS.Strength*/, weight /*double*/){
			var cn = StayConstraint.new(v, strength || Strength.weak, weight || 1)
			return this.addConstraint(cn)
		}

		// FIXME(slightlyoff): add a removeStay

		removeConstraint(cn /*CS.Constraint*/){
			// console.log("removeConstraint('", cn, "')");
			CS.trace && CS.fnenterprint("removeConstraintInternal: " + cn)
			CS.trace && CS.traceprint(this.toString())
			
			this._needsSolving = true
			this._resetStayConstants()

			var zRow = this.rows.get(this._objective)
			var eVars = /* Set */this._errorVars.get(cn)

			CS.trace && CS.traceprint("eVars == " + eVars);
			
			if (eVars != null){
				eVars.each(function(cv){
					var expr = this.rows.get(cv)
					if (expr == null){
						zRow.addVariable(cv, -cn.weight * cn.strength.symbolicWeight.value, this._objective, this)
					} 
					else {
						zRow.addExpression(expr, -cn.weight * cn.strength.symbolicWeight.value, this._objective, this)
					}
					CS.trace && CS.traceprint("now eVars == " + eVars)
				}, this)
			}
			var marker = this._markerVars.get(cn)
			this._markerVars.delete(cn)
			if (marker == null){
				throw InternalError.new("Constraint not found in removeConstraintInternal")
			}
			CS.trace && CS.traceprint("Looking to remove var " + marker)
			if (this.rows.get(marker) == null){
				var col = this.columns.get(marker)
				// console.log("col is:", col, "from marker:", marker);
				CS.trace && CS.traceprint("Must pivot -- columns are " + col)
				var exitVar = null
				var minRatio = 0
				col.each(function(v){
					if (v.isRestricted){
						var expr = this.rows.get(v)
						var coeff = expr.coefficientFor(marker)
						CS.trace && CS.traceprint("Marker " + marker + "'s coefficient in " + expr + " is " + coeff)
						if (coeff < 0){
							var r = -expr.constant / coeff
							if (exitVar == null ||
								r < minRatio    ||
								(CS.approx(r, minRatio) && v.hashCode < exitVar.hashCode)){
								minRatio = r
								exitVar = v
							}
						}
					}
				}, this)
				if (exitVar == null){
					CS.trace && CS.traceprint("exitVar is still null")
					col.each(function(v){
						if (v.isRestricted){
							var expr = this.rows.get(v)
							var coeff = expr.coefficientFor(marker)
							var r = expr.constant / coeff
							if (exitVar == null || r < minRatio){
								minRatio = r
								exitVar = v
							}
						}
					}, this)
				}
				if (exitVar == null){
					if (col.size == 0){
						this.removeColumn(marker)
					}
					else {
						col.escapingEach(function(v){
							if (v != this._objective){
								exitVar = v
								return { brk: true }
							}
						}, this)
					}
				}
				if (exitVar != null){
					this.pivot(marker, exitVar)
				}
			}
			if (this.rows.get(marker) != null){
				var expr = this.removeRow(marker)
			}

			if (eVars != null){
				eVars.each(function(v){
					if (v != marker){ this.removeColumn(v) }
				}, this)
			}

			if (cn.isStayConstraint){
				if (eVars != null){
					for (var i = 0; i < this._stayPlusErrorVars.length; i++){
						eVars.delete(this._stayPlusErrorVars[i])
						eVars.delete(this._stayMinusErrorVars[i])
					}
				}
			} 
			else if (cn.isEditConstraint){
				assert(eVars != null)
				var cei = this._editVarMap.get(cn.variable)
				this.removeColumn(cei.editMinus)
				this._editVarMap.delete(cn.variable)
			}

			if (eVars != null){
				this._errorVars.delete(eVars)
			}

			if (this.autoSolve){
				this.optimize(this._objective)
				this._setExternalVariables()
			}

			return this
		}

		reset(){
			CS.trace && CS.fnenterprint("reset")
			throw InternalError.new("reset not implemented")
		}

		resolveArray(newEditConstants){
			CS.trace && CS.fnenterprint("resolveArray" + newEditConstants)
			var l = newEditConstants.length
			this._editVarMap.each(function(v, cei){
				var i = cei.index
				if (i < l) this.suggestValue(v, newEditConstants[i])
			}, this)
			this.resolve()
		}

		resolvePair(x /*double*/, y /*double*/){
			this.suggestValue(this._editVarList[0].v, x)
			this.suggestValue(this._editVarList[1].v, y)
			this.resolve()
		}

		resolve(){
			CS.trace && CS.fnenterprint("resolve()")
			this.dualOptimize()
			this._setExternalVariables()
			this._infeasibleRows.clear()
			this._resetStayConstants()
		}

		suggestValue(v /*CS.Variable*/, x /*double*/){
			CS.trace && console.log("suggestValue(" + v + ", " + x + ")")
			var cei = this._editVarMap.get(v)
			if (!cei){
				throw CSError.new("suggestValue for variable " + v + ", but var is not an edit variable")
			}
			var delta = x - cei.prevEditConstant
			cei.prevEditConstant = x
			this.deltaEditConstant(delta, cei.editPlus, cei.editMinus)
			return this
		}

		solve(){
			if (this._needsSolving){
				this.optimize(this._objective)
				this._setExternalVariables()
			}
			return this
		}

		setEditedValue(v /*CS.Variable*/, n /*double*/){
			if (!(this.columnsHasKey(v) || (this.rows.get(v) != null))){
				v.value = n
				return this
			}

			if (!CS.approx(n, v.value)){
				this.addEditVar(v)
				this.beginEdit()

				try {
					this.suggestValue(v, n)
				} 
				catch (e){
					throw InternalError.new("Error in setEditedValue")
				}

				this.endEdit()
			}
			return this
		}

		addVar(v /*CS.Variable*/){
			if (!(this.columnsHasKey(v) || (this.rows.get(v) != null))){
				try {
					this.addStay(v)
				} 
				catch (e /*CS.RequiredFailure*/){
					throw InternalError.new("Error in addVar -- required failure is impossible")
				}

				CS.trace && CS.traceprint("added initial stay on " + v)
			}
			return this;
		}

		getInternalInfo(){
			var retstr = Tableau::getInternalInfo()
			retstr += "\nSolver info:\n"
			retstr += "Stay Error Variables: "
			retstr += this._stayPlusErrorVars.length + this._stayMinusErrorVars.length
			retstr += " (" + this._stayPlusErrorVars.length + " +, "
			retstr += this._stayMinusErrorVars.length + " -)\n"
			retstr += "Edit Variables: " + this._editVarMap.size
			retstr += "\n"
			return retstr
		}

		getDebugInfo(){
			return this.toString() + this.getInternalInfo() + "\n"
		}

		toString(){
			var bstr = Tableau::getInternalInfo(this)
			bstr += "\n_stayPlusErrorVars: "
			bstr += '[' + this._stayPlusErrorVars + ']'
			bstr += "\n_stayMinusErrorVars: "
			bstr += '[' + this._stayMinusErrorVars + ']'
			bstr += "\n"
			bstr += "_editVarMap:\n" + this._editVarMap
			bstr += "\n"
			return bstr
		}

		addWithArtificialVariable(expr /*CS.Expression*/){
			CS.trace && CS.fnenterprint("addWithArtificialVariable: " + expr)
			var av = SlackVariable.new({
				value: ++this._artificialCounter,
				prefix: "a"
			})
			var az = ObjectiveVariable.new({ name: "az" })
			var azRow = /* CS.Expression */expr.clone()
			CS.trace && CS.traceprint("before addRows:\n" + this)
			this.addRow(az, azRow)
			this.addRow(av, expr)
			CS.trace && CS.traceprint("after addRows:\n" + this)
			this.optimize(az)
			var azTableauRow = this.rows.get(az)
			CS.trace && CS.traceprint("azTableauRow.constant == " + azTableauRow.constant)
			if (!CS.approx(azTableauRow.constant, 0)){
				this.removeRow(az)
				this.removeColumn(av)
				throw RequiredFailure.new()
			}
			var e = this.rows.get(av)
			if (e != null){
				if (e.isConstant){
					this.removeRow(av)
					this.removeRow(az)
					return
				}
				var entryVar = e.anyPivotableVariable()
				this.pivot(entryVar, av)
			}
			assert(this.rows.get(av) == null)
			this.removeColumn(av)
			this.removeRow(az)
		},

		tryAddingDirectly(expr /*CS.Expression*/){
			CS.trace && CS.fnenterprint("tryAddingDirectly: " + expr)
			var subject = this.chooseSubject(expr)
			if (subject == null){
				CS.trace && CS.fnexitprint("returning false")
				return false
			}
			expr.newSubject(subject)
			if (this.columnsHasKey(subject)){
				this.substituteOut(subject, expr)
			}
			this.addRow(subject, expr)
			CS.trace && CS.fnexitprint("returning true")
			return true
		}

		chooseSubject(expr /*CS.Expression*/){
			CS.trace && CS.fnenterprint("chooseSubject: " + expr)
			var subject = null
			var foundUnrestricted = false
			var foundNewRestricted = false
			var terms = expr.terms
			var rv = terms.escapingEach(function(v, c){
				if (foundUnrestricted){
					if (!v.isRestricted){
						if (!this.columnsHasKey(v)){
							return { retval: v }
						}
					}
				} 
				else {
					if (v.isRestricted){
						if (!foundNewRestricted && !v.isDummy && c < 0){
							var col = this.columns.get(v);
							if (col == null ||
									(col.size == 1 && this.columnsHasKey(this._objective))
							){
								subject = v
								foundNewRestricted = true
							}
						}
					} else {
						subject = v
						foundUnrestricted = true
					}
				}
			}, this)
			if (rv && rv.retval !== undefined){
				return rv.retval
			}

			if (subject != null){
				return subject
			}

			var coeff = 0

			// subject is nil.
			// Make one last check -- if all of the variables in expr are dummy
			// variables, then we can pick a dummy variable as the subject
			var rv = terms.escapingEach(function(v,c){
				if (!v.isDummy)  {
					return {retval:null}
				}
				if (!this.columnsHasKey(v)){
					subject = v
					coeff = c
				}
			}, this)
			if (rv && rv.retval !== undefined) return rv.retval

			if (!CS.approx(expr.constant, 0)){
				throw RequiredFailure.new()
			}
			if (coeff > 0){
				expr.multiplyMe(-1)
			}
			return subject
		}

		deltaEditConstant(delta /*double*/, plusErrorVar /*CS.AbstractVariable*/, minusErrorVar /*CS.AbstractVariable*/){
			if (CS.trace)
				CS.fnenterprint("deltaEditConstant :" + delta + ", " + plusErrorVar + ", " + minusErrorVar)

			var exprPlus = this.rows.get(plusErrorVar)
			if (exprPlus != null){
				exprPlus.constant += delta
				if (exprPlus.constant < 0){
					this._infeasibleRows.add(plusErrorVar)
				}
				return
			}
			var exprMinus = this.rows.get(minusErrorVar)
			if (exprMinus != null){
				exprMinus.constant += -delta
				if (exprMinus.constant < 0){
					this._infeasibleRows.add(minusErrorVar)
				}
				return
			}
			var columnVars = this.columns.get(minusErrorVar)
			if (!columnVars){
				console.log("columnVars is null -- tableau is:\n" + this)
			}
			columnVars.each(function(basicVar){
				var expr = this.rows.get(basicVar)
				var c = expr.coefficientFor(minusErrorVar)
				expr.constant += (c * delta)
				if (basicVar.isRestricted && expr.constant < 0){
					this._infeasibleRows.add(basicVar)
				}
			}, this)
		}

		// We have set new values for the constants in the edit constraints.
		// Re-Optimize using the dual simplex algorithm.
		dualOptimize(){
			CS.trace && CS.fnenterprint("dualOptimize:")
			var zRow = this.rows.get(this._objective)
			// need to handle infeasible rows
			while (this._infeasibleRows.size){
				var exitVar = this._infeasibleRows.values()[0]
				this._infeasibleRows.delete(exitVar)
				var entryVar = null
				var expr = this.rows.get(exitVar)
				// exitVar might have become basic after some other pivoting
				// so allow for the case of its not being there any longer
				if (expr){
					if (expr.constant < 0){
						var ratio = Number.MAX_VALUE
						var r
						var terms = expr.terms
						terms.each(function(v, cd){
							if (cd > 0 && v.isPivotable){
								var zc = zRow.coefficientFor(v)
								r = zc / cd
								if (r < ratio || (CS.approx(r, ratio) && v.hashCode < entryVar.hashCode)){
									entryVar = v
									ratio = r
								}
							}
						})
						if (ratio == Number.MAX_VALUE){
							throw InternalError.new("ratio == nil (MAX_VALUE) in dualOptimize")
						}
						this.pivot(entryVar, exitVar)
					}
				}
			}
		}

		// Make a new linear Expression representing the constraint cn,
		// replacing any basic variables with their defining expressions.
		// Normalize if necessary so that the Constant is non-negative.  If
		// the constraint is non-required give its error variables an
		// appropriate weight in the objective function.
		newExpression(cn /*CS.Constraint*/, /** outputs to **/ eplus_eminus /*Array*/, prevEConstant){
			if (CS.trace){
				CS.fnenterprint("newExpression: " + cn)
				CS.traceprint("cn.isInequality == " + cn.isInequality)
				CS.traceprint("cn.required == " + cn.isRequired)
			}

			var cnExpr = cn.expression
			var expr = CS.Expression.fromConstant(cnExpr.constant)
			var slackVar = CS.SlackVariable.new()
			var dummyVar = CS.DummyVariable.new()
			var eminus = CS.SlackVariable.new()
			var eplus = CS.SlackVariable.new()
			var cnTerms = cnExpr.terms
			// console.log(cnTerms.size);

			cnTerms.each(function(v, c){
				var e = this.rows.get(v)
				if (!e){
					expr.addVariable(v, c)
				} 
				else {
					expr.addExpression(e, c)
				}
			}, this)

			if (cn.isInequality){
				// cn is an inequality, so Add a slack variable. The original constraint
				// is expr>=0, so that the resulting equality is expr-slackVar=0. If cn is
				// also non-required Add a negative error variable, giving:
				//
				//    expr - slackVar = -errorVar
				//
				// in other words:
				//
				//    expr - slackVar + errorVar = 0
				//
				// Since both of these variables are newly created we can just Add
				// them to the Expression (they can't be basic).
				CS.trace && CS.traceprint("Inequality, adding slack")
				++this._slackCounter
				slackVar = SlackVariable.new({
					value: this._slackCounter,
					prefix: "s"
				})
				expr.setVariable(slackVar, -1)

				this._markerVars.set(cn, slackVar)
				if (!cn.isRequired){
					++this._slackCounter
					eminus = SlackVariable.new({
						value: this._slackCounter,
						prefix: "em"
					})
					expr.setVariable(eminus, 1)

					var zRow = this.rows.get(this._objective)
					zRow.setVariable(eminus, cn.strength.symbolicWeight.value * cn.weight)
					this.insertErrorVar(cn, eminus)
					this.noteAddedVariable(eminus, this._objective)
				}
			} 
			else {
				if (cn.isRequired){
					CS.trace && CS.traceprint("Equality, required")
					// Add a dummy variable to the Expression to serve as a marker for this
					// constraint.  The dummy variable is never allowed to enter the basis
					// when pivoting.
					++this._dummyCounter
					dummyVar = CS.DummyVariable.new({
						value: this._dummyCounter,
						prefix: "d"
					})
					eplus_eminus[0] = dummyVar
					eplus_eminus[1] = dummyVar
					prevEConstant[0] = cnExpr.constant

					expr.setVariable(dummyVar, 1)
					this._markerVars.set(cn, dummyVar)

					CS.trace && CS.traceprint("Adding dummyVar == d" + this._dummyCounter)
				} 
				else {
					// cn is a non-required equality. Add a positive and a negative error
					// variable, making the resulting constraint
					//       expr = eplus - eminus
					// in other words:
					//       expr - eplus + eminus = 0
					CS.trace && CS.traceprint("Equality, not required")
					++this._slackCounter
					eplus = SlackVariable.new({
						value: this._slackCounter,
						prefix: "ep"
					})
					eminus = SlackVariable.new({
						value: this._slackCounter,
						prefix: "em"
					})

					expr.setVariable(eplus, -1)
					expr.setVariable(eminus, 1)

					this._markerVars.set(cn, eplus)
					var zRow = this.rows.get(this._objective)
					CS.trace && console.log(zRow)

					var swCoeff = cn.strength.symbolicWeight.value * cn.weight
					if (swCoeff == 0){
						CS.trace && CS.traceprint("cn == " + cn)
						CS.trace && CS.traceprint("adding " + eplus + " and " + eminus + " with swCoeff == " + swCoeff)
					}

					zRow.setVariable(eplus, swCoeff)
					this.noteAddedVariable(eplus, this._objective)

					zRow.setVariable(eminus, swCoeff)
					this.noteAddedVariable(eminus, this._objective)

					this.insertErrorVar(cn, eminus)
					this.insertErrorVar(cn, eplus)

					if (cn.isStayConstraint){
						this._stayPlusErrorVars[this._stayPlusErrorVars.length] = eplus
						this._stayMinusErrorVars[this._stayMinusErrorVars.length] = eminus
					} 
					else if (cn.isEditConstraint){
						eplus_eminus[0] = eplus
						eplus_eminus[1] = eminus
						prevEConstant[0] = cnExpr.constant
					}
				}
			}
			// the Constant in the Expression should be non-negative. If necessary
			// normalize the Expression by multiplying by -1
			if (expr.constant < 0) expr.multiplyMe(-1)
			CS.trace && CS.fnexitprint("returning " + expr)
			return expr
		},

		// Minimize the value of the objective.  (The tableau should already be
		// feasible.)
		optimize(zVar /*CS.ObjectiveVariable*/){
			CS.trace && CS.fnenterprint("optimize: " + zVar)
			CS.trace && CS.traceprint(this.toString())
			this._optimizeCount++

			var zRow = this.rows.get(zVar)
			assert(zRow != null)
			var entryVar = null
			var exitVar = null
			var objectiveCoeff, terms

			while (true){
				objectiveCoeff = 0
				terms = zRow.terms

				// Find the most negative coefficient in the objective function (ignoring
				// the non-pivotable dummy variables). If all coefficients are positive
				// we're done
				terms.escapingEach(function(v, c){
					if (v.isPivotable && c < objectiveCoeff){
						objectiveCoeff = c
						entryVar = v
						// Break on success
						return { brk: 1 }
					}
				}, this)

				if (objectiveCoeff >= -epsilon)
					return

				CS.trace && console.log("entryVar:", entryVar, "objectiveCoeff:", objectiveCoeff)

				// choose which variable to move out of the basis
				// Only consider pivotable basic variables
				// (i.e. restricted, non-dummy variables)
				var minRatio = Number.MAX_VALUE
				var columnVars = this.columns.get(entryVar)
				var r = 0

				columnVars.each(function(v){
					CS.trace && CS.traceprint("Checking " + v)
					if (v.isPivotable){
						var expr = this.rows.get(v)
						var coeff = expr.coefficientFor(entryVar)
						CS.trace && CS.traceprint("pivotable, coeff = " + coeff)
						// only consider negative coefficients
						if (coeff < 0){
							r = -expr.constant / coeff
							// Bland's anti-cycling rule:
							// if multiple variables are about the same,
							// always pick the lowest via some total
							// ordering -- I use their addresses in memory
							//    if (r < minRatio ||
							//              (CS.approx(r, minRatio) &&
							//               v.get_pclv() < exitVar.get_pclv()))
							if (r < minRatio || (CS.approx(r, minRatio) && v.hashCode < exitVar.hashCode)){
								minRatio = r
								exitVar = v
							}
						}
					}
				}, this)

				// If minRatio is still nil at this point, it means that the
				// objective function is unbounded, i.e. it can become
				// arbitrarily negative.  This should never happen in this
				// application.
				if (minRatio == Number.MAX_VALUE){
					throw InternalError.new("Objective function is unbounded in optimize");
				}

				// console.time("SimplexSolver::optimize pivot()");
				this.pivot(entryVar, exitVar)
				// console.timeEnd("SimplexSolver::optimize pivot()");

				CS.trace && CS.traceprint(this.toString())
			}
		}

		// Do a Pivot.  Move entryVar into the basis (i.e. make it a basic variable),
		// and move exitVar out of the basis (i.e., make it a parametric variable)
		pivot(entryVar /*CS.AbstractVariable*/, exitVar /*CS.AbstractVariable*/){
			CS.trace && console.log("pivot: ", entryVar, exitVar)
			var time = false

			time && console.time(" SimplexSolver::pivot")

			// the entryVar might be non-pivotable if we're doing a RemoveConstraint --
			// otherwise it should be a pivotable variable -- enforced at call sites,
			// hopefully
			if (entryVar == null){
				console.warn("pivot: entryVar == null")
			}

			if (exitVar == null){
				console.warn("pivot: exitVar == null");
			}
			// console.log("SimplexSolver::pivot(", entryVar, exitVar, ")")

			// expr is the Expression for the exit variable (about to leave the basis) --
			// so that the old tableau includes the equation:
			//   exitVar = expr
			time && console.time("  removeRow");
			var expr = this.removeRow(exitVar);
			time && console.timeEnd("  removeRow");

			// Compute an Expression for the entry variable.  Since expr has
			// been deleted from the tableau we can destructively modify it to
			// build this Expression.
			time && console.time("  changeSubject");
			expr.changeSubject(exitVar, entryVar);
			time && console.timeEnd("  changeSubject");

			time && console.time("  substituteOut");
			this.substituteOut(entryVar, expr);
			time && console.timeEnd("  substituteOut");
			/*
			if (entryVar.isExternal){
				// entry var is no longer a parametric variable since we're moving
				// it into the basis
				console.log("entryVar is external!");
				this._externalParametricVars.delete(entryVar);
			}
			*/

			time && console.time("  addRow")
			this.addRow(entryVar, expr);
			time && console.timeEnd("  addRow")

			time && console.timeEnd(" SimplexSolver::pivot")
		}

		// Each of the non-required stays will be represented by an equation
		// of the form
		//     v = c + eplus - eminus
		// where v is the variable with the stay, c is the previous value of
		// v, and eplus and eminus are slack variables that hold the error
		// in satisfying the stay constraint.  We are about to change
		// something, and we want to fix the constants in the equations
		// representing the stays.  If both eplus and eminus are nonbasic
		// they have value 0 in the current solution, meaning the previous
		// stay was exactly satisfied.  In this case nothing needs to be
		// changed.  Otherwise one of them is basic, and the other must
		// occur only in the Expression for that basic error variable.
		// Reset the Constant in this Expression to 0.
		_resetStayConstants(){
			CS.trace && console.log("_resetStayConstants")
			var spev = this._stayPlusErrorVars
			var l = spev.length
			for (var i = 0; i < l; i++){
				var expr = this.rows.get(spev[i])
				if (expr === null){
					expr = this.rows.get(this._stayMinusErrorVars[i])
				}
				if (expr != null){
					expr.constant = 0
				}
			}
		}

		_setExternalVariables(){
			CS.trace && CS.fnenterprint("_setExternalVariables:")
			CS.trace && CS.traceprint(this.toString())
			var changed = {}

			// console.log("this._externalParametricVars:", this._externalParametricVars);
			this._externalParametricVars.each(function(v){
				if (this.rows.get(v) != null){
					if (CS.trace)
						console.log("Error: variable" + v + " in _externalParametricVars is basic")
				} 
				else {
					v.value = 0
					changed[v.name] = 0
				}
			}, this)
			// console.log("this._externalRows:", this._externalRows);
			this._externalRows.each(function(v){
				var expr = this.rows.get(v)
				if (v.value != expr.constant){
					// console.log(v.toString(), v.value, expr.constant);
					v.value = expr.constant
					changed[v.name] = expr.constant
					if(v._sig) v._sig.set(expr.constant)
				}
				// CS.trace && console.log("v == " + v);
				// CS.trace && console.log("expr == " + expr);
			}, this);
			this._changed = changed
			this._needsSolving = false
			this._informCallbacks()
			this.onsolved()
		},

		onsolved(){
			// Lifecycle stub. Here for dirty, dirty monkey patching.
		}

		_informCallbacks(){
			if(!this._callbacks) return

			var changed = this._changed
			this._callbacks.forEach(function(fn){
				fn(changed)
			})
		}

		_addCallback(fn){
			var a = (this._callbacks || (this._callbacks = []))
			a[a.length] = fn
		}

		insertErrorVar(cn /*CS.Constraint*/, aVar /*CS.AbstractVariable*/){
			CS.trace && CS.fnenterprint("insertErrorVar:" + cn + ", " + aVar)
			var constraintSet = /* Set */this._errorVars.get(aVar)
			if (!constraintSet){
				constraintSet = HashSet.new()
				this._errorVars.set(cn, constraintSet)
			}
			constraintSet.add(aVar)
		}
	}

	var multiplier = 1000

	class SymbolicWeight{
		constructor(/*w1, w2, w3*/){
			this.value = 0
			var factor = 1
			for (var i = arguments.length - 1; i >= 0; --i){
				this.value += arguments[i] * factor
				factor *= multiplier
			}
		}
	}

	class Strength{
		constructor(name /*String*/, symbolicWeight, w2, w3){
			this.name = name
			if (SymbolicWeight.isPrototypeOf(symbolicWeight)){
				this.symbolicWeight = symbolicWeight
			} 
			else {
				this.symbolicWeight = SymbolicWeight.new(symbolicWeight, w2, w3)
			}
		}

		get isRequired(){
			return (this === CS.Strength.required)
		}

		toString(){
			return this.name + (!this.isRequired ? (":" + this.symbolicWeight) : "")
		}


	}

	/* public static final */
	Strength.required = Strength.new("<Required>", 1000, 1000, 1000)
	/* public static final  */
	Strength.strong = Strength.new("strong", 1, 0, 0)
	/* public static final  */
	Strength.medium = Strength.new("medium", 0, 1, 0)
	/* public static final  */
	Strength.weak = Strength.new("weak", 0, 0, 1)

	class AbstractVariable{
		isDummy = false
		isExternal = false
		isPivotable = false
		isRestricted = false

		constructor(args, varNamePrefix){
			// Common mixin initialization.
			this.hashCode = CS._inc()
			this.name = (varNamePrefix||"") + this.hashCode
			if (args){
				if (typeof args.name != "undefined"){
					this.name = args.name
				}
				if (typeof args.value != "undefined"){
					this.value = args.value
				}
				if (typeof args.prefix != "undefined"){
					this._prefix = args.prefix
				}
			}
		}

		_prefix = ""
		name =  ""
		value = 0

		valueOf(){ return this.value }

		toString(){
			return this._prefix + "[" + this.name + ":" + this.value + "]"
		}

	}

	class Variable extends AbstractVariable{
		_constructor(args){
			this.constructor(args, "v")
			var vm = Variable._map
			if (vm){ vm[this.name] = this }
		}
		isExternal = true
	}

	class DummyVariable extends AbstractVariable{
		_constructor(args){
			this.constructor(args, "d")
		}
		isDummy = true
		isRestricted = true
		value = "dummy"
	}

	class ObjectiveVariable extends AbstractVariable{
		_constructor(args){
			this.constructor(args, "o")
		}
		value = "obj"
	}

	class SlackVariable extends AbstractVariable{
		_constructor(args){
			this.constructor(args, "s")
		}
		isPivotable = true
		isRestricted = true
		value = "slack"
	}
}
